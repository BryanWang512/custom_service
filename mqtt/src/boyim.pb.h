// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: boyim.proto

#ifndef PROTOBUF_boyim_2eproto__INCLUDED
#define PROTOBUF_boyim_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace boyim_proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_boyim_2eproto();
void protobuf_AssignDesc_boyim_2eproto();
void protobuf_ShutdownFile_boyim_2eproto();

class Header;
class LoginRequest;
class LoginResponse;
class ServiceReady;
class ServiceReadyResponse;
class ClientEntry;
class ChatReadyRequest;
class ChatReadyResponse;
class ChatMessage;
class ChatMessageAck;
class FunctionMessage;
class FunctionMessageResponse;
class LogoutMessage;
class ServiceStatus;
class ShiftSession;
class EndSession;

// ===================================================================

class Header : public ::google::protobuf::Message {
 public:
  Header();
  virtual ~Header();

  Header(const Header& from);

  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Header& default_instance();

  void Swap(Header* other);

  // implements Message ----------------------------------------------

  Header* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Header& from);
  void MergeFrom(const Header& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string gid = 1;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 1;
  inline const ::std::string& gid() const;
  inline void set_gid(const ::std::string& value);
  inline void set_gid(const char* value);
  inline void set_gid(const char* value, size_t size);
  inline ::std::string* mutable_gid();
  inline ::std::string* release_gid();
  inline void set_allocated_gid(::std::string* gid);

  // required string site_id = 2;
  inline bool has_site_id() const;
  inline void clear_site_id();
  static const int kSiteIdFieldNumber = 2;
  inline const ::std::string& site_id() const;
  inline void set_site_id(const ::std::string& value);
  inline void set_site_id(const char* value);
  inline void set_site_id(const char* value, size_t size);
  inline ::std::string* mutable_site_id();
  inline ::std::string* release_site_id();
  inline void set_allocated_site_id(::std::string* site_id);

  // required string station_id = 3;
  inline bool has_station_id() const;
  inline void clear_station_id();
  static const int kStationIdFieldNumber = 3;
  inline const ::std::string& station_id() const;
  inline void set_station_id(const ::std::string& value);
  inline void set_station_id(const char* value);
  inline void set_station_id(const char* value, size_t size);
  inline ::std::string* mutable_station_id();
  inline ::std::string* release_station_id();
  inline void set_allocated_station_id(::std::string* station_id);

  // required string role = 4;
  inline bool has_role() const;
  inline void clear_role();
  static const int kRoleFieldNumber = 4;
  inline const ::std::string& role() const;
  inline void set_role(const ::std::string& value);
  inline void set_role(const char* value);
  inline void set_role(const char* value, size_t size);
  inline ::std::string* mutable_role();
  inline ::std::string* release_role();
  inline void set_allocated_role(::std::string* role);

  // @@protoc_insertion_point(class_scope:boyim_proto.Header)
 private:
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_site_id();
  inline void clear_has_site_id();
  inline void set_has_station_id();
  inline void clear_has_station_id();
  inline void set_has_role();
  inline void clear_has_role();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* gid_;
  ::std::string* site_id_;
  ::std::string* station_id_;
  ::std::string* role_;
  friend void  protobuf_AddDesc_boyim_2eproto();
  friend void protobuf_AssignDesc_boyim_2eproto();
  friend void protobuf_ShutdownFile_boyim_2eproto();

  void InitAsDefaultInstance();
  static Header* default_instance_;
};
// -------------------------------------------------------------------

class LoginRequest : public ::google::protobuf::Message {
 public:
  LoginRequest();
  virtual ~LoginRequest();

  LoginRequest(const LoginRequest& from);

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginRequest& default_instance();

  void Swap(LoginRequest* other);

  // implements Message ----------------------------------------------

  LoginRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginRequest& from);
  void MergeFrom(const LoginRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .boyim_proto.Header header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::boyim_proto::Header& header() const;
  inline ::boyim_proto::Header* mutable_header();
  inline ::boyim_proto::Header* release_header();
  inline void set_allocated_header(::boyim_proto::Header* header);

  // optional string preferred_service_fid = 2;
  inline bool has_preferred_service_fid() const;
  inline void clear_preferred_service_fid();
  static const int kPreferredServiceFidFieldNumber = 2;
  inline const ::std::string& preferred_service_fid() const;
  inline void set_preferred_service_fid(const ::std::string& value);
  inline void set_preferred_service_fid(const char* value);
  inline void set_preferred_service_fid(const char* value, size_t size);
  inline ::std::string* mutable_preferred_service_fid();
  inline ::std::string* release_preferred_service_fid();
  inline void set_allocated_preferred_service_fid(::std::string* preferred_service_fid);

  // optional string dest_service_fid = 3;
  inline bool has_dest_service_fid() const;
  inline void clear_dest_service_fid();
  static const int kDestServiceFidFieldNumber = 3;
  inline const ::std::string& dest_service_fid() const;
  inline void set_dest_service_fid(const ::std::string& value);
  inline void set_dest_service_fid(const char* value);
  inline void set_dest_service_fid(const char* value, size_t size);
  inline ::std::string* mutable_dest_service_fid();
  inline ::std::string* release_dest_service_fid();
  inline void set_allocated_dest_service_fid(::std::string* dest_service_fid);

  // optional string from_service_fid = 4;
  inline bool has_from_service_fid() const;
  inline void clear_from_service_fid();
  static const int kFromServiceFidFieldNumber = 4;
  inline const ::std::string& from_service_fid() const;
  inline void set_from_service_fid(const ::std::string& value);
  inline void set_from_service_fid(const char* value);
  inline void set_from_service_fid(const char* value, size_t size);
  inline ::std::string* mutable_from_service_fid();
  inline ::std::string* release_from_service_fid();
  inline void set_allocated_from_service_fid(::std::string* from_service_fid);

  // @@protoc_insertion_point(class_scope:boyim_proto.LoginRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_preferred_service_fid();
  inline void clear_has_preferred_service_fid();
  inline void set_has_dest_service_fid();
  inline void clear_has_dest_service_fid();
  inline void set_has_from_service_fid();
  inline void clear_has_from_service_fid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::boyim_proto::Header* header_;
  ::std::string* preferred_service_fid_;
  ::std::string* dest_service_fid_;
  ::std::string* from_service_fid_;
  friend void  protobuf_AddDesc_boyim_2eproto();
  friend void protobuf_AssignDesc_boyim_2eproto();
  friend void protobuf_ShutdownFile_boyim_2eproto();

  void InitAsDefaultInstance();
  static LoginRequest* default_instance_;
};
// -------------------------------------------------------------------

class LoginResponse : public ::google::protobuf::Message {
 public:
  LoginResponse();
  virtual ~LoginResponse();

  LoginResponse(const LoginResponse& from);

  inline LoginResponse& operator=(const LoginResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginResponse& default_instance();

  void Swap(LoginResponse* other);

  // implements Message ----------------------------------------------

  LoginResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginResponse& from);
  void MergeFrom(const LoginResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // optional string session_id = 2;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 2;
  inline const ::std::string& session_id() const;
  inline void set_session_id(const ::std::string& value);
  inline void set_session_id(const char* value);
  inline void set_session_id(const char* value, size_t size);
  inline ::std::string* mutable_session_id();
  inline ::std::string* release_session_id();
  inline void set_allocated_session_id(::std::string* session_id);

  // optional string role = 3;
  inline bool has_role() const;
  inline void clear_role();
  static const int kRoleFieldNumber = 3;
  inline const ::std::string& role() const;
  inline void set_role(const ::std::string& value);
  inline void set_role(const char* value);
  inline void set_role(const char* value, size_t size);
  inline ::std::string* mutable_role();
  inline ::std::string* release_role();
  inline void set_allocated_role(::std::string* role);

  // optional string return_msg = 4;
  inline bool has_return_msg() const;
  inline void clear_return_msg();
  static const int kReturnMsgFieldNumber = 4;
  inline const ::std::string& return_msg() const;
  inline void set_return_msg(const ::std::string& value);
  inline void set_return_msg(const char* value);
  inline void set_return_msg(const char* value, size_t size);
  inline ::std::string* mutable_return_msg();
  inline ::std::string* release_return_msg();
  inline void set_allocated_return_msg(::std::string* return_msg);

  // optional string service_gid = 11;
  inline bool has_service_gid() const;
  inline void clear_service_gid();
  static const int kServiceGidFieldNumber = 11;
  inline const ::std::string& service_gid() const;
  inline void set_service_gid(const ::std::string& value);
  inline void set_service_gid(const char* value);
  inline void set_service_gid(const char* value, size_t size);
  inline ::std::string* mutable_service_gid();
  inline ::std::string* release_service_gid();
  inline void set_allocated_service_gid(::std::string* service_gid);

  // optional string service_site_id = 12;
  inline bool has_service_site_id() const;
  inline void clear_service_site_id();
  static const int kServiceSiteIdFieldNumber = 12;
  inline const ::std::string& service_site_id() const;
  inline void set_service_site_id(const ::std::string& value);
  inline void set_service_site_id(const char* value);
  inline void set_service_site_id(const char* value, size_t size);
  inline ::std::string* mutable_service_site_id();
  inline ::std::string* release_service_site_id();
  inline void set_allocated_service_site_id(::std::string* service_site_id);

  // optional string service_station_id = 13;
  inline bool has_service_station_id() const;
  inline void clear_service_station_id();
  static const int kServiceStationIdFieldNumber = 13;
  inline const ::std::string& service_station_id() const;
  inline void set_service_station_id(const ::std::string& value);
  inline void set_service_station_id(const char* value);
  inline void set_service_station_id(const char* value, size_t size);
  inline ::std::string* mutable_service_station_id();
  inline ::std::string* release_service_station_id();
  inline void set_allocated_service_station_id(::std::string* service_station_id);

  // optional int32 wait_count = 14;
  inline bool has_wait_count() const;
  inline void clear_wait_count();
  static const int kWaitCountFieldNumber = 14;
  inline ::google::protobuf::int32 wait_count() const;
  inline void set_wait_count(::google::protobuf::int32 value);

  // repeated string serve_apps = 21;
  inline int serve_apps_size() const;
  inline void clear_serve_apps();
  static const int kServeAppsFieldNumber = 21;
  inline const ::std::string& serve_apps(int index) const;
  inline ::std::string* mutable_serve_apps(int index);
  inline void set_serve_apps(int index, const ::std::string& value);
  inline void set_serve_apps(int index, const char* value);
  inline void set_serve_apps(int index, const char* value, size_t size);
  inline ::std::string* add_serve_apps();
  inline void add_serve_apps(const ::std::string& value);
  inline void add_serve_apps(const char* value);
  inline void add_serve_apps(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& serve_apps() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_serve_apps();

  // @@protoc_insertion_point(class_scope:boyim_proto.LoginResponse)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_role();
  inline void clear_has_role();
  inline void set_has_return_msg();
  inline void clear_has_return_msg();
  inline void set_has_service_gid();
  inline void clear_has_service_gid();
  inline void set_has_service_site_id();
  inline void clear_has_service_site_id();
  inline void set_has_service_station_id();
  inline void clear_has_service_station_id();
  inline void set_has_wait_count();
  inline void clear_has_wait_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* session_id_;
  ::std::string* role_;
  ::std::string* return_msg_;
  ::google::protobuf::int32 code_;
  ::google::protobuf::int32 wait_count_;
  ::std::string* service_gid_;
  ::std::string* service_site_id_;
  ::std::string* service_station_id_;
  ::google::protobuf::RepeatedPtrField< ::std::string> serve_apps_;
  friend void  protobuf_AddDesc_boyim_2eproto();
  friend void protobuf_AssignDesc_boyim_2eproto();
  friend void protobuf_ShutdownFile_boyim_2eproto();

  void InitAsDefaultInstance();
  static LoginResponse* default_instance_;
};
// -------------------------------------------------------------------

class ServiceReady : public ::google::protobuf::Message {
 public:
  ServiceReady();
  virtual ~ServiceReady();

  ServiceReady(const ServiceReady& from);

  inline ServiceReady& operator=(const ServiceReady& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServiceReady& default_instance();

  void Swap(ServiceReady* other);

  // implements Message ----------------------------------------------

  ServiceReady* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServiceReady& from);
  void MergeFrom(const ServiceReady& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .boyim_proto.Header header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::boyim_proto::Header& header() const;
  inline ::boyim_proto::Header* mutable_header();
  inline ::boyim_proto::Header* release_header();
  inline void set_allocated_header(::boyim_proto::Header* header);

  // @@protoc_insertion_point(class_scope:boyim_proto.ServiceReady)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::boyim_proto::Header* header_;
  friend void  protobuf_AddDesc_boyim_2eproto();
  friend void protobuf_AssignDesc_boyim_2eproto();
  friend void protobuf_ShutdownFile_boyim_2eproto();

  void InitAsDefaultInstance();
  static ServiceReady* default_instance_;
};
// -------------------------------------------------------------------

class ServiceReadyResponse : public ::google::protobuf::Message {
 public:
  ServiceReadyResponse();
  virtual ~ServiceReadyResponse();

  ServiceReadyResponse(const ServiceReadyResponse& from);

  inline ServiceReadyResponse& operator=(const ServiceReadyResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServiceReadyResponse& default_instance();

  void Swap(ServiceReadyResponse* other);

  // implements Message ----------------------------------------------

  ServiceReadyResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServiceReadyResponse& from);
  void MergeFrom(const ServiceReadyResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // optional string client_fid = 2;
  inline bool has_client_fid() const;
  inline void clear_client_fid();
  static const int kClientFidFieldNumber = 2;
  inline const ::std::string& client_fid() const;
  inline void set_client_fid(const ::std::string& value);
  inline void set_client_fid(const char* value);
  inline void set_client_fid(const char* value, size_t size);
  inline ::std::string* mutable_client_fid();
  inline ::std::string* release_client_fid();
  inline void set_allocated_client_fid(::std::string* client_fid);

  // optional int64 client_login_clock = 3;
  inline bool has_client_login_clock() const;
  inline void clear_client_login_clock();
  static const int kClientLoginClockFieldNumber = 3;
  inline ::google::protobuf::int64 client_login_clock() const;
  inline void set_client_login_clock(::google::protobuf::int64 value);

  // optional int32 wait_count = 4;
  inline bool has_wait_count() const;
  inline void clear_wait_count();
  static const int kWaitCountFieldNumber = 4;
  inline ::google::protobuf::int32 wait_count() const;
  inline void set_wait_count(::google::protobuf::int32 value);

  // repeated .boyim_proto.ClientEntry client_entries = 5;
  inline int client_entries_size() const;
  inline void clear_client_entries();
  static const int kClientEntriesFieldNumber = 5;
  inline const ::boyim_proto::ClientEntry& client_entries(int index) const;
  inline ::boyim_proto::ClientEntry* mutable_client_entries(int index);
  inline ::boyim_proto::ClientEntry* add_client_entries();
  inline const ::google::protobuf::RepeatedPtrField< ::boyim_proto::ClientEntry >&
      client_entries() const;
  inline ::google::protobuf::RepeatedPtrField< ::boyim_proto::ClientEntry >*
      mutable_client_entries();

  // @@protoc_insertion_point(class_scope:boyim_proto.ServiceReadyResponse)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_client_fid();
  inline void clear_has_client_fid();
  inline void set_has_client_login_clock();
  inline void clear_has_client_login_clock();
  inline void set_has_wait_count();
  inline void clear_has_wait_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* client_fid_;
  ::google::protobuf::int32 code_;
  ::google::protobuf::int32 wait_count_;
  ::google::protobuf::int64 client_login_clock_;
  ::google::protobuf::RepeatedPtrField< ::boyim_proto::ClientEntry > client_entries_;
  friend void  protobuf_AddDesc_boyim_2eproto();
  friend void protobuf_AssignDesc_boyim_2eproto();
  friend void protobuf_ShutdownFile_boyim_2eproto();

  void InitAsDefaultInstance();
  static ServiceReadyResponse* default_instance_;
};
// -------------------------------------------------------------------

class ClientEntry : public ::google::protobuf::Message {
 public:
  ClientEntry();
  virtual ~ClientEntry();

  ClientEntry(const ClientEntry& from);

  inline ClientEntry& operator=(const ClientEntry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientEntry& default_instance();

  void Swap(ClientEntry* other);

  // implements Message ----------------------------------------------

  ClientEntry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientEntry& from);
  void MergeFrom(const ClientEntry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string client_fid = 1;
  inline bool has_client_fid() const;
  inline void clear_client_fid();
  static const int kClientFidFieldNumber = 1;
  inline const ::std::string& client_fid() const;
  inline void set_client_fid(const ::std::string& value);
  inline void set_client_fid(const char* value);
  inline void set_client_fid(const char* value, size_t size);
  inline ::std::string* mutable_client_fid();
  inline ::std::string* release_client_fid();
  inline void set_allocated_client_fid(::std::string* client_fid);

  // required int64 start_clock = 2;
  inline bool has_start_clock() const;
  inline void clear_start_clock();
  static const int kStartClockFieldNumber = 2;
  inline ::google::protobuf::int64 start_clock() const;
  inline void set_start_clock(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:boyim_proto.ClientEntry)
 private:
  inline void set_has_client_fid();
  inline void clear_has_client_fid();
  inline void set_has_start_clock();
  inline void clear_has_start_clock();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* client_fid_;
  ::google::protobuf::int64 start_clock_;
  friend void  protobuf_AddDesc_boyim_2eproto();
  friend void protobuf_AssignDesc_boyim_2eproto();
  friend void protobuf_ShutdownFile_boyim_2eproto();

  void InitAsDefaultInstance();
  static ClientEntry* default_instance_;
};
// -------------------------------------------------------------------

class ChatReadyRequest : public ::google::protobuf::Message {
 public:
  ChatReadyRequest();
  virtual ~ChatReadyRequest();

  ChatReadyRequest(const ChatReadyRequest& from);

  inline ChatReadyRequest& operator=(const ChatReadyRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChatReadyRequest& default_instance();

  void Swap(ChatReadyRequest* other);

  // implements Message ----------------------------------------------

  ChatReadyRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChatReadyRequest& from);
  void MergeFrom(const ChatReadyRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .boyim_proto.Header header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::boyim_proto::Header& header() const;
  inline ::boyim_proto::Header* mutable_header();
  inline ::boyim_proto::Header* release_header();
  inline void set_allocated_header(::boyim_proto::Header* header);

  // required string session_id = 2;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 2;
  inline const ::std::string& session_id() const;
  inline void set_session_id(const ::std::string& value);
  inline void set_session_id(const char* value);
  inline void set_session_id(const char* value, size_t size);
  inline ::std::string* mutable_session_id();
  inline ::std::string* release_session_id();
  inline void set_allocated_session_id(::std::string* session_id);

  // required string client_info = 3;
  inline bool has_client_info() const;
  inline void clear_client_info();
  static const int kClientInfoFieldNumber = 3;
  inline const ::std::string& client_info() const;
  inline void set_client_info(const ::std::string& value);
  inline void set_client_info(const char* value);
  inline void set_client_info(const char* value, size_t size);
  inline ::std::string* mutable_client_info();
  inline ::std::string* release_client_info();
  inline void set_allocated_client_info(::std::string* client_info);

  // @@protoc_insertion_point(class_scope:boyim_proto.ChatReadyRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_client_info();
  inline void clear_has_client_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::boyim_proto::Header* header_;
  ::std::string* session_id_;
  ::std::string* client_info_;
  friend void  protobuf_AddDesc_boyim_2eproto();
  friend void protobuf_AssignDesc_boyim_2eproto();
  friend void protobuf_ShutdownFile_boyim_2eproto();

  void InitAsDefaultInstance();
  static ChatReadyRequest* default_instance_;
};
// -------------------------------------------------------------------

class ChatReadyResponse : public ::google::protobuf::Message {
 public:
  ChatReadyResponse();
  virtual ~ChatReadyResponse();

  ChatReadyResponse(const ChatReadyResponse& from);

  inline ChatReadyResponse& operator=(const ChatReadyResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChatReadyResponse& default_instance();

  void Swap(ChatReadyResponse* other);

  // implements Message ----------------------------------------------

  ChatReadyResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChatReadyResponse& from);
  void MergeFrom(const ChatReadyResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .boyim_proto.Header header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::boyim_proto::Header& header() const;
  inline ::boyim_proto::Header* mutable_header();
  inline ::boyim_proto::Header* release_header();
  inline void set_allocated_header(::boyim_proto::Header* header);

  // required string session_id = 2;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 2;
  inline const ::std::string& session_id() const;
  inline void set_session_id(const ::std::string& value);
  inline void set_session_id(const char* value);
  inline void set_session_id(const char* value, size_t size);
  inline ::std::string* mutable_session_id();
  inline ::std::string* release_session_id();
  inline void set_allocated_session_id(::std::string* session_id);

  // required int32 code = 3;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 3;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // optional string service_info = 4;
  inline bool has_service_info() const;
  inline void clear_service_info();
  static const int kServiceInfoFieldNumber = 4;
  inline const ::std::string& service_info() const;
  inline void set_service_info(const ::std::string& value);
  inline void set_service_info(const char* value);
  inline void set_service_info(const char* value, size_t size);
  inline ::std::string* mutable_service_info();
  inline ::std::string* release_service_info();
  inline void set_allocated_service_info(::std::string* service_info);

  // @@protoc_insertion_point(class_scope:boyim_proto.ChatReadyResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_service_info();
  inline void clear_has_service_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::boyim_proto::Header* header_;
  ::std::string* session_id_;
  ::std::string* service_info_;
  ::google::protobuf::int32 code_;
  friend void  protobuf_AddDesc_boyim_2eproto();
  friend void protobuf_AssignDesc_boyim_2eproto();
  friend void protobuf_ShutdownFile_boyim_2eproto();

  void InitAsDefaultInstance();
  static ChatReadyResponse* default_instance_;
};
// -------------------------------------------------------------------

class ChatMessage : public ::google::protobuf::Message {
 public:
  ChatMessage();
  virtual ~ChatMessage();

  ChatMessage(const ChatMessage& from);

  inline ChatMessage& operator=(const ChatMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChatMessage& default_instance();

  void Swap(ChatMessage* other);

  // implements Message ----------------------------------------------

  ChatMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChatMessage& from);
  void MergeFrom(const ChatMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .boyim_proto.Header header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::boyim_proto::Header& header() const;
  inline ::boyim_proto::Header* mutable_header();
  inline ::boyim_proto::Header* release_header();
  inline void set_allocated_header(::boyim_proto::Header* header);

  // required string session_id = 2;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 2;
  inline const ::std::string& session_id() const;
  inline void set_session_id(const ::std::string& value);
  inline void set_session_id(const char* value);
  inline void set_session_id(const char* value, size_t size);
  inline ::std::string* mutable_session_id();
  inline ::std::string* release_session_id();
  inline void set_allocated_session_id(::std::string* session_id);

  // required int64 seq_id = 3;
  inline bool has_seq_id() const;
  inline void clear_seq_id();
  static const int kSeqIdFieldNumber = 3;
  inline ::google::protobuf::int64 seq_id() const;
  inline void set_seq_id(::google::protobuf::int64 value);

  // required string type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // required string msg = 5;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 5;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const char* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  inline void set_allocated_msg(::std::string* msg);

  // @@protoc_insertion_point(class_scope:boyim_proto.ChatMessage)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_seq_id();
  inline void clear_has_seq_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_msg();
  inline void clear_has_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::boyim_proto::Header* header_;
  ::std::string* session_id_;
  ::google::protobuf::int64 seq_id_;
  ::std::string* type_;
  ::std::string* msg_;
  friend void  protobuf_AddDesc_boyim_2eproto();
  friend void protobuf_AssignDesc_boyim_2eproto();
  friend void protobuf_ShutdownFile_boyim_2eproto();

  void InitAsDefaultInstance();
  static ChatMessage* default_instance_;
};
// -------------------------------------------------------------------

class ChatMessageAck : public ::google::protobuf::Message {
 public:
  ChatMessageAck();
  virtual ~ChatMessageAck();

  ChatMessageAck(const ChatMessageAck& from);

  inline ChatMessageAck& operator=(const ChatMessageAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChatMessageAck& default_instance();

  void Swap(ChatMessageAck* other);

  // implements Message ----------------------------------------------

  ChatMessageAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChatMessageAck& from);
  void MergeFrom(const ChatMessageAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .boyim_proto.Header header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::boyim_proto::Header& header() const;
  inline ::boyim_proto::Header* mutable_header();
  inline ::boyim_proto::Header* release_header();
  inline void set_allocated_header(::boyim_proto::Header* header);

  // required string session_id = 2;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 2;
  inline const ::std::string& session_id() const;
  inline void set_session_id(const ::std::string& value);
  inline void set_session_id(const char* value);
  inline void set_session_id(const char* value, size_t size);
  inline ::std::string* mutable_session_id();
  inline ::std::string* release_session_id();
  inline void set_allocated_session_id(::std::string* session_id);

  // repeated int64 seq_ids = 3;
  inline int seq_ids_size() const;
  inline void clear_seq_ids();
  static const int kSeqIdsFieldNumber = 3;
  inline ::google::protobuf::int64 seq_ids(int index) const;
  inline void set_seq_ids(int index, ::google::protobuf::int64 value);
  inline void add_seq_ids(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      seq_ids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_seq_ids();

  // @@protoc_insertion_point(class_scope:boyim_proto.ChatMessageAck)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_session_id();
  inline void clear_has_session_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::boyim_proto::Header* header_;
  ::std::string* session_id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > seq_ids_;
  friend void  protobuf_AddDesc_boyim_2eproto();
  friend void protobuf_AssignDesc_boyim_2eproto();
  friend void protobuf_ShutdownFile_boyim_2eproto();

  void InitAsDefaultInstance();
  static ChatMessageAck* default_instance_;
};
// -------------------------------------------------------------------

class FunctionMessage : public ::google::protobuf::Message {
 public:
  FunctionMessage();
  virtual ~FunctionMessage();

  FunctionMessage(const FunctionMessage& from);

  inline FunctionMessage& operator=(const FunctionMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FunctionMessage& default_instance();

  void Swap(FunctionMessage* other);

  // implements Message ----------------------------------------------

  FunctionMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FunctionMessage& from);
  void MergeFrom(const FunctionMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .boyim_proto.Header header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::boyim_proto::Header& header() const;
  inline ::boyim_proto::Header* mutable_header();
  inline ::boyim_proto::Header* release_header();
  inline void set_allocated_header(::boyim_proto::Header* header);

  // required string session_id = 2;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 2;
  inline const ::std::string& session_id() const;
  inline void set_session_id(const ::std::string& value);
  inline void set_session_id(const char* value);
  inline void set_session_id(const char* value, size_t size);
  inline ::std::string* mutable_session_id();
  inline ::std::string* release_session_id();
  inline void set_allocated_session_id(::std::string* session_id);

  // required int64 seq_id = 3;
  inline bool has_seq_id() const;
  inline void clear_seq_id();
  static const int kSeqIdFieldNumber = 3;
  inline ::google::protobuf::int64 seq_id() const;
  inline void set_seq_id(::google::protobuf::int64 value);

  // required string function = 4;
  inline bool has_function() const;
  inline void clear_function();
  static const int kFunctionFieldNumber = 4;
  inline const ::std::string& function() const;
  inline void set_function(const ::std::string& value);
  inline void set_function(const char* value);
  inline void set_function(const char* value, size_t size);
  inline ::std::string* mutable_function();
  inline ::std::string* release_function();
  inline void set_allocated_function(::std::string* function);

  // @@protoc_insertion_point(class_scope:boyim_proto.FunctionMessage)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_seq_id();
  inline void clear_has_seq_id();
  inline void set_has_function();
  inline void clear_has_function();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::boyim_proto::Header* header_;
  ::std::string* session_id_;
  ::google::protobuf::int64 seq_id_;
  ::std::string* function_;
  friend void  protobuf_AddDesc_boyim_2eproto();
  friend void protobuf_AssignDesc_boyim_2eproto();
  friend void protobuf_ShutdownFile_boyim_2eproto();

  void InitAsDefaultInstance();
  static FunctionMessage* default_instance_;
};
// -------------------------------------------------------------------

class FunctionMessageResponse : public ::google::protobuf::Message {
 public:
  FunctionMessageResponse();
  virtual ~FunctionMessageResponse();

  FunctionMessageResponse(const FunctionMessageResponse& from);

  inline FunctionMessageResponse& operator=(const FunctionMessageResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FunctionMessageResponse& default_instance();

  void Swap(FunctionMessageResponse* other);

  // implements Message ----------------------------------------------

  FunctionMessageResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FunctionMessageResponse& from);
  void MergeFrom(const FunctionMessageResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // required string session_id = 2;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 2;
  inline const ::std::string& session_id() const;
  inline void set_session_id(const ::std::string& value);
  inline void set_session_id(const char* value);
  inline void set_session_id(const char* value, size_t size);
  inline ::std::string* mutable_session_id();
  inline ::std::string* release_session_id();
  inline void set_allocated_session_id(::std::string* session_id);

  // required int64 seq_id = 3;
  inline bool has_seq_id() const;
  inline void clear_seq_id();
  static const int kSeqIdFieldNumber = 3;
  inline ::google::protobuf::int64 seq_id() const;
  inline void set_seq_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:boyim_proto.FunctionMessageResponse)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_seq_id();
  inline void clear_has_seq_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* session_id_;
  ::google::protobuf::int64 seq_id_;
  ::google::protobuf::int32 code_;
  friend void  protobuf_AddDesc_boyim_2eproto();
  friend void protobuf_AssignDesc_boyim_2eproto();
  friend void protobuf_ShutdownFile_boyim_2eproto();

  void InitAsDefaultInstance();
  static FunctionMessageResponse* default_instance_;
};
// -------------------------------------------------------------------

class LogoutMessage : public ::google::protobuf::Message {
 public:
  LogoutMessage();
  virtual ~LogoutMessage();

  LogoutMessage(const LogoutMessage& from);

  inline LogoutMessage& operator=(const LogoutMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogoutMessage& default_instance();

  void Swap(LogoutMessage* other);

  // implements Message ----------------------------------------------

  LogoutMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogoutMessage& from);
  void MergeFrom(const LogoutMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .boyim_proto.Header header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::boyim_proto::Header& header() const;
  inline ::boyim_proto::Header* mutable_header();
  inline ::boyim_proto::Header* release_header();
  inline void set_allocated_header(::boyim_proto::Header* header);

  // optional string session_id = 2;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 2;
  inline const ::std::string& session_id() const;
  inline void set_session_id(const ::std::string& value);
  inline void set_session_id(const char* value);
  inline void set_session_id(const char* value, size_t size);
  inline ::std::string* mutable_session_id();
  inline ::std::string* release_session_id();
  inline void set_allocated_session_id(::std::string* session_id);

  // optional int64 clock = 3;
  inline bool has_clock() const;
  inline void clear_clock();
  static const int kClockFieldNumber = 3;
  inline ::google::protobuf::int64 clock() const;
  inline void set_clock(::google::protobuf::int64 value);

  // optional string service_gid = 4;
  inline bool has_service_gid() const;
  inline void clear_service_gid();
  static const int kServiceGidFieldNumber = 4;
  inline const ::std::string& service_gid() const;
  inline void set_service_gid(const ::std::string& value);
  inline void set_service_gid(const char* value);
  inline void set_service_gid(const char* value, size_t size);
  inline ::std::string* mutable_service_gid();
  inline ::std::string* release_service_gid();
  inline void set_allocated_service_gid(::std::string* service_gid);

  // optional string service_site_id = 5;
  inline bool has_service_site_id() const;
  inline void clear_service_site_id();
  static const int kServiceSiteIdFieldNumber = 5;
  inline const ::std::string& service_site_id() const;
  inline void set_service_site_id(const ::std::string& value);
  inline void set_service_site_id(const char* value);
  inline void set_service_site_id(const char* value, size_t size);
  inline ::std::string* mutable_service_site_id();
  inline ::std::string* release_service_site_id();
  inline void set_allocated_service_site_id(::std::string* service_site_id);

  // optional string service_station_id = 6;
  inline bool has_service_station_id() const;
  inline void clear_service_station_id();
  static const int kServiceStationIdFieldNumber = 6;
  inline const ::std::string& service_station_id() const;
  inline void set_service_station_id(const ::std::string& value);
  inline void set_service_station_id(const char* value);
  inline void set_service_station_id(const char* value, size_t size);
  inline ::std::string* mutable_service_station_id();
  inline ::std::string* release_service_station_id();
  inline void set_allocated_service_station_id(::std::string* service_station_id);

  // optional int32 end_type = 7;
  inline bool has_end_type() const;
  inline void clear_end_type();
  static const int kEndTypeFieldNumber = 7;
  inline ::google::protobuf::int32 end_type() const;
  inline void set_end_type(::google::protobuf::int32 value);

  // optional string extra = 11;
  inline bool has_extra() const;
  inline void clear_extra();
  static const int kExtraFieldNumber = 11;
  inline const ::std::string& extra() const;
  inline void set_extra(const ::std::string& value);
  inline void set_extra(const char* value);
  inline void set_extra(const char* value, size_t size);
  inline ::std::string* mutable_extra();
  inline ::std::string* release_extra();
  inline void set_allocated_extra(::std::string* extra);

  // @@protoc_insertion_point(class_scope:boyim_proto.LogoutMessage)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_clock();
  inline void clear_has_clock();
  inline void set_has_service_gid();
  inline void clear_has_service_gid();
  inline void set_has_service_site_id();
  inline void clear_has_service_site_id();
  inline void set_has_service_station_id();
  inline void clear_has_service_station_id();
  inline void set_has_end_type();
  inline void clear_has_end_type();
  inline void set_has_extra();
  inline void clear_has_extra();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::boyim_proto::Header* header_;
  ::std::string* session_id_;
  ::google::protobuf::int64 clock_;
  ::std::string* service_gid_;
  ::std::string* service_site_id_;
  ::std::string* service_station_id_;
  ::std::string* extra_;
  ::google::protobuf::int32 end_type_;
  friend void  protobuf_AddDesc_boyim_2eproto();
  friend void protobuf_AssignDesc_boyim_2eproto();
  friend void protobuf_ShutdownFile_boyim_2eproto();

  void InitAsDefaultInstance();
  static LogoutMessage* default_instance_;
};
// -------------------------------------------------------------------

class ServiceStatus : public ::google::protobuf::Message {
 public:
  ServiceStatus();
  virtual ~ServiceStatus();

  ServiceStatus(const ServiceStatus& from);

  inline ServiceStatus& operator=(const ServiceStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServiceStatus& default_instance();

  void Swap(ServiceStatus* other);

  // implements Message ----------------------------------------------

  ServiceStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServiceStatus& from);
  void MergeFrom(const ServiceStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .boyim_proto.Header header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::boyim_proto::Header& header() const;
  inline ::boyim_proto::Header* mutable_header();
  inline ::boyim_proto::Header* release_header();
  inline void set_allocated_header(::boyim_proto::Header* header);

  // required int32 status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:boyim_proto.ServiceStatus)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::boyim_proto::Header* header_;
  ::google::protobuf::int32 status_;
  friend void  protobuf_AddDesc_boyim_2eproto();
  friend void protobuf_AssignDesc_boyim_2eproto();
  friend void protobuf_ShutdownFile_boyim_2eproto();

  void InitAsDefaultInstance();
  static ServiceStatus* default_instance_;
};
// -------------------------------------------------------------------

class ShiftSession : public ::google::protobuf::Message {
 public:
  ShiftSession();
  virtual ~ShiftSession();

  ShiftSession(const ShiftSession& from);

  inline ShiftSession& operator=(const ShiftSession& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShiftSession& default_instance();

  void Swap(ShiftSession* other);

  // implements Message ----------------------------------------------

  ShiftSession* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ShiftSession& from);
  void MergeFrom(const ShiftSession& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .boyim_proto.Header header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::boyim_proto::Header& header() const;
  inline ::boyim_proto::Header* mutable_header();
  inline ::boyim_proto::Header* release_header();
  inline void set_allocated_header(::boyim_proto::Header* header);

  // required string session_id = 2;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 2;
  inline const ::std::string& session_id() const;
  inline void set_session_id(const ::std::string& value);
  inline void set_session_id(const char* value);
  inline void set_session_id(const char* value, size_t size);
  inline ::std::string* mutable_session_id();
  inline ::std::string* release_session_id();
  inline void set_allocated_session_id(::std::string* session_id);

  // required string shift_to_fid = 3;
  inline bool has_shift_to_fid() const;
  inline void clear_shift_to_fid();
  static const int kShiftToFidFieldNumber = 3;
  inline const ::std::string& shift_to_fid() const;
  inline void set_shift_to_fid(const ::std::string& value);
  inline void set_shift_to_fid(const char* value);
  inline void set_shift_to_fid(const char* value, size_t size);
  inline ::std::string* mutable_shift_to_fid();
  inline ::std::string* release_shift_to_fid();
  inline void set_allocated_shift_to_fid(::std::string* shift_to_fid);

  // @@protoc_insertion_point(class_scope:boyim_proto.ShiftSession)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_shift_to_fid();
  inline void clear_has_shift_to_fid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::boyim_proto::Header* header_;
  ::std::string* session_id_;
  ::std::string* shift_to_fid_;
  friend void  protobuf_AddDesc_boyim_2eproto();
  friend void protobuf_AssignDesc_boyim_2eproto();
  friend void protobuf_ShutdownFile_boyim_2eproto();

  void InitAsDefaultInstance();
  static ShiftSession* default_instance_;
};
// -------------------------------------------------------------------

class EndSession : public ::google::protobuf::Message {
 public:
  EndSession();
  virtual ~EndSession();

  EndSession(const EndSession& from);

  inline EndSession& operator=(const EndSession& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EndSession& default_instance();

  void Swap(EndSession* other);

  // implements Message ----------------------------------------------

  EndSession* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EndSession& from);
  void MergeFrom(const EndSession& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .boyim_proto.Header header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::boyim_proto::Header& header() const;
  inline ::boyim_proto::Header* mutable_header();
  inline ::boyim_proto::Header* release_header();
  inline void set_allocated_header(::boyim_proto::Header* header);

  // required string session_id = 2;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 2;
  inline const ::std::string& session_id() const;
  inline void set_session_id(const ::std::string& value);
  inline void set_session_id(const char* value);
  inline void set_session_id(const char* value, size_t size);
  inline ::std::string* mutable_session_id();
  inline ::std::string* release_session_id();
  inline void set_allocated_session_id(::std::string* session_id);

  // required string client_gid = 3;
  inline bool has_client_gid() const;
  inline void clear_client_gid();
  static const int kClientGidFieldNumber = 3;
  inline const ::std::string& client_gid() const;
  inline void set_client_gid(const ::std::string& value);
  inline void set_client_gid(const char* value);
  inline void set_client_gid(const char* value, size_t size);
  inline ::std::string* mutable_client_gid();
  inline ::std::string* release_client_gid();
  inline void set_allocated_client_gid(::std::string* client_gid);

  // required string client_site_id = 4;
  inline bool has_client_site_id() const;
  inline void clear_client_site_id();
  static const int kClientSiteIdFieldNumber = 4;
  inline const ::std::string& client_site_id() const;
  inline void set_client_site_id(const ::std::string& value);
  inline void set_client_site_id(const char* value);
  inline void set_client_site_id(const char* value, size_t size);
  inline ::std::string* mutable_client_site_id();
  inline ::std::string* release_client_site_id();
  inline void set_allocated_client_site_id(::std::string* client_site_id);

  // required string client_station_id = 5;
  inline bool has_client_station_id() const;
  inline void clear_client_station_id();
  static const int kClientStationIdFieldNumber = 5;
  inline const ::std::string& client_station_id() const;
  inline void set_client_station_id(const ::std::string& value);
  inline void set_client_station_id(const char* value);
  inline void set_client_station_id(const char* value, size_t size);
  inline ::std::string* mutable_client_station_id();
  inline ::std::string* release_client_station_id();
  inline void set_allocated_client_station_id(::std::string* client_station_id);

  // optional int32 archive_class = 6;
  inline bool has_archive_class() const;
  inline void clear_archive_class();
  static const int kArchiveClassFieldNumber = 6;
  inline ::google::protobuf::int32 archive_class() const;
  inline void set_archive_class(::google::protobuf::int32 value);

  // optional int32 archive_category = 7;
  inline bool has_archive_category() const;
  inline void clear_archive_category();
  static const int kArchiveCategoryFieldNumber = 7;
  inline ::google::protobuf::int32 archive_category() const;
  inline void set_archive_category(::google::protobuf::int32 value);

  // optional int32 session_upgraded = 8;
  inline bool has_session_upgraded() const;
  inline void clear_session_upgraded();
  static const int kSessionUpgradedFieldNumber = 8;
  inline ::google::protobuf::int32 session_upgraded() const;
  inline void set_session_upgraded(::google::protobuf::int32 value);

  // optional int32 session_invalid = 9;
  inline bool has_session_invalid() const;
  inline void clear_session_invalid();
  static const int kSessionInvalidFieldNumber = 9;
  inline ::google::protobuf::int32 session_invalid() const;
  inline void set_session_invalid(::google::protobuf::int32 value);

  // optional int32 end_type = 10;
  inline bool has_end_type() const;
  inline void clear_end_type();
  static const int kEndTypeFieldNumber = 10;
  inline ::google::protobuf::int32 end_type() const;
  inline void set_end_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:boyim_proto.EndSession)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_client_gid();
  inline void clear_has_client_gid();
  inline void set_has_client_site_id();
  inline void clear_has_client_site_id();
  inline void set_has_client_station_id();
  inline void clear_has_client_station_id();
  inline void set_has_archive_class();
  inline void clear_has_archive_class();
  inline void set_has_archive_category();
  inline void clear_has_archive_category();
  inline void set_has_session_upgraded();
  inline void clear_has_session_upgraded();
  inline void set_has_session_invalid();
  inline void clear_has_session_invalid();
  inline void set_has_end_type();
  inline void clear_has_end_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::boyim_proto::Header* header_;
  ::std::string* session_id_;
  ::std::string* client_gid_;
  ::std::string* client_site_id_;
  ::std::string* client_station_id_;
  ::google::protobuf::int32 archive_class_;
  ::google::protobuf::int32 archive_category_;
  ::google::protobuf::int32 session_upgraded_;
  ::google::protobuf::int32 session_invalid_;
  ::google::protobuf::int32 end_type_;
  friend void  protobuf_AddDesc_boyim_2eproto();
  friend void protobuf_AssignDesc_boyim_2eproto();
  friend void protobuf_ShutdownFile_boyim_2eproto();

  void InitAsDefaultInstance();
  static EndSession* default_instance_;
};
// ===================================================================


// ===================================================================

// Header

// required string gid = 1;
inline bool Header::has_gid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Header::set_has_gid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Header::clear_has_gid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Header::clear_gid() {
  if (gid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gid_->clear();
  }
  clear_has_gid();
}
inline const ::std::string& Header::gid() const {
  // @@protoc_insertion_point(field_get:boyim_proto.Header.gid)
  return *gid_;
}
inline void Header::set_gid(const ::std::string& value) {
  set_has_gid();
  if (gid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gid_ = new ::std::string;
  }
  gid_->assign(value);
  // @@protoc_insertion_point(field_set:boyim_proto.Header.gid)
}
inline void Header::set_gid(const char* value) {
  set_has_gid();
  if (gid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gid_ = new ::std::string;
  }
  gid_->assign(value);
  // @@protoc_insertion_point(field_set_char:boyim_proto.Header.gid)
}
inline void Header::set_gid(const char* value, size_t size) {
  set_has_gid();
  if (gid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gid_ = new ::std::string;
  }
  gid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:boyim_proto.Header.gid)
}
inline ::std::string* Header::mutable_gid() {
  set_has_gid();
  if (gid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:boyim_proto.Header.gid)
  return gid_;
}
inline ::std::string* Header::release_gid() {
  clear_has_gid();
  if (gid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = gid_;
    gid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Header::set_allocated_gid(::std::string* gid) {
  if (gid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete gid_;
  }
  if (gid) {
    set_has_gid();
    gid_ = gid;
  } else {
    clear_has_gid();
    gid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:boyim_proto.Header.gid)
}

// required string site_id = 2;
inline bool Header::has_site_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Header::set_has_site_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Header::clear_has_site_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Header::clear_site_id() {
  if (site_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    site_id_->clear();
  }
  clear_has_site_id();
}
inline const ::std::string& Header::site_id() const {
  // @@protoc_insertion_point(field_get:boyim_proto.Header.site_id)
  return *site_id_;
}
inline void Header::set_site_id(const ::std::string& value) {
  set_has_site_id();
  if (site_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    site_id_ = new ::std::string;
  }
  site_id_->assign(value);
  // @@protoc_insertion_point(field_set:boyim_proto.Header.site_id)
}
inline void Header::set_site_id(const char* value) {
  set_has_site_id();
  if (site_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    site_id_ = new ::std::string;
  }
  site_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:boyim_proto.Header.site_id)
}
inline void Header::set_site_id(const char* value, size_t size) {
  set_has_site_id();
  if (site_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    site_id_ = new ::std::string;
  }
  site_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:boyim_proto.Header.site_id)
}
inline ::std::string* Header::mutable_site_id() {
  set_has_site_id();
  if (site_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    site_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:boyim_proto.Header.site_id)
  return site_id_;
}
inline ::std::string* Header::release_site_id() {
  clear_has_site_id();
  if (site_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = site_id_;
    site_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Header::set_allocated_site_id(::std::string* site_id) {
  if (site_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete site_id_;
  }
  if (site_id) {
    set_has_site_id();
    site_id_ = site_id;
  } else {
    clear_has_site_id();
    site_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:boyim_proto.Header.site_id)
}

// required string station_id = 3;
inline bool Header::has_station_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Header::set_has_station_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Header::clear_has_station_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Header::clear_station_id() {
  if (station_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    station_id_->clear();
  }
  clear_has_station_id();
}
inline const ::std::string& Header::station_id() const {
  // @@protoc_insertion_point(field_get:boyim_proto.Header.station_id)
  return *station_id_;
}
inline void Header::set_station_id(const ::std::string& value) {
  set_has_station_id();
  if (station_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    station_id_ = new ::std::string;
  }
  station_id_->assign(value);
  // @@protoc_insertion_point(field_set:boyim_proto.Header.station_id)
}
inline void Header::set_station_id(const char* value) {
  set_has_station_id();
  if (station_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    station_id_ = new ::std::string;
  }
  station_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:boyim_proto.Header.station_id)
}
inline void Header::set_station_id(const char* value, size_t size) {
  set_has_station_id();
  if (station_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    station_id_ = new ::std::string;
  }
  station_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:boyim_proto.Header.station_id)
}
inline ::std::string* Header::mutable_station_id() {
  set_has_station_id();
  if (station_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    station_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:boyim_proto.Header.station_id)
  return station_id_;
}
inline ::std::string* Header::release_station_id() {
  clear_has_station_id();
  if (station_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = station_id_;
    station_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Header::set_allocated_station_id(::std::string* station_id) {
  if (station_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete station_id_;
  }
  if (station_id) {
    set_has_station_id();
    station_id_ = station_id;
  } else {
    clear_has_station_id();
    station_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:boyim_proto.Header.station_id)
}

// required string role = 4;
inline bool Header::has_role() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Header::set_has_role() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Header::clear_has_role() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Header::clear_role() {
  if (role_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    role_->clear();
  }
  clear_has_role();
}
inline const ::std::string& Header::role() const {
  // @@protoc_insertion_point(field_get:boyim_proto.Header.role)
  return *role_;
}
inline void Header::set_role(const ::std::string& value) {
  set_has_role();
  if (role_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    role_ = new ::std::string;
  }
  role_->assign(value);
  // @@protoc_insertion_point(field_set:boyim_proto.Header.role)
}
inline void Header::set_role(const char* value) {
  set_has_role();
  if (role_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    role_ = new ::std::string;
  }
  role_->assign(value);
  // @@protoc_insertion_point(field_set_char:boyim_proto.Header.role)
}
inline void Header::set_role(const char* value, size_t size) {
  set_has_role();
  if (role_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    role_ = new ::std::string;
  }
  role_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:boyim_proto.Header.role)
}
inline ::std::string* Header::mutable_role() {
  set_has_role();
  if (role_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    role_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:boyim_proto.Header.role)
  return role_;
}
inline ::std::string* Header::release_role() {
  clear_has_role();
  if (role_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = role_;
    role_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Header::set_allocated_role(::std::string* role) {
  if (role_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete role_;
  }
  if (role) {
    set_has_role();
    role_ = role;
  } else {
    clear_has_role();
    role_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:boyim_proto.Header.role)
}

// -------------------------------------------------------------------

// LoginRequest

// required .boyim_proto.Header header = 1;
inline bool LoginRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginRequest::clear_header() {
  if (header_ != NULL) header_->::boyim_proto::Header::Clear();
  clear_has_header();
}
inline const ::boyim_proto::Header& LoginRequest::header() const {
  // @@protoc_insertion_point(field_get:boyim_proto.LoginRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::boyim_proto::Header* LoginRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::boyim_proto::Header;
  // @@protoc_insertion_point(field_mutable:boyim_proto.LoginRequest.header)
  return header_;
}
inline ::boyim_proto::Header* LoginRequest::release_header() {
  clear_has_header();
  ::boyim_proto::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void LoginRequest::set_allocated_header(::boyim_proto::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:boyim_proto.LoginRequest.header)
}

// optional string preferred_service_fid = 2;
inline bool LoginRequest::has_preferred_service_fid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginRequest::set_has_preferred_service_fid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginRequest::clear_has_preferred_service_fid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginRequest::clear_preferred_service_fid() {
  if (preferred_service_fid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    preferred_service_fid_->clear();
  }
  clear_has_preferred_service_fid();
}
inline const ::std::string& LoginRequest::preferred_service_fid() const {
  // @@protoc_insertion_point(field_get:boyim_proto.LoginRequest.preferred_service_fid)
  return *preferred_service_fid_;
}
inline void LoginRequest::set_preferred_service_fid(const ::std::string& value) {
  set_has_preferred_service_fid();
  if (preferred_service_fid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    preferred_service_fid_ = new ::std::string;
  }
  preferred_service_fid_->assign(value);
  // @@protoc_insertion_point(field_set:boyim_proto.LoginRequest.preferred_service_fid)
}
inline void LoginRequest::set_preferred_service_fid(const char* value) {
  set_has_preferred_service_fid();
  if (preferred_service_fid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    preferred_service_fid_ = new ::std::string;
  }
  preferred_service_fid_->assign(value);
  // @@protoc_insertion_point(field_set_char:boyim_proto.LoginRequest.preferred_service_fid)
}
inline void LoginRequest::set_preferred_service_fid(const char* value, size_t size) {
  set_has_preferred_service_fid();
  if (preferred_service_fid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    preferred_service_fid_ = new ::std::string;
  }
  preferred_service_fid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:boyim_proto.LoginRequest.preferred_service_fid)
}
inline ::std::string* LoginRequest::mutable_preferred_service_fid() {
  set_has_preferred_service_fid();
  if (preferred_service_fid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    preferred_service_fid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:boyim_proto.LoginRequest.preferred_service_fid)
  return preferred_service_fid_;
}
inline ::std::string* LoginRequest::release_preferred_service_fid() {
  clear_has_preferred_service_fid();
  if (preferred_service_fid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = preferred_service_fid_;
    preferred_service_fid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoginRequest::set_allocated_preferred_service_fid(::std::string* preferred_service_fid) {
  if (preferred_service_fid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete preferred_service_fid_;
  }
  if (preferred_service_fid) {
    set_has_preferred_service_fid();
    preferred_service_fid_ = preferred_service_fid;
  } else {
    clear_has_preferred_service_fid();
    preferred_service_fid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:boyim_proto.LoginRequest.preferred_service_fid)
}

// optional string dest_service_fid = 3;
inline bool LoginRequest::has_dest_service_fid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginRequest::set_has_dest_service_fid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginRequest::clear_has_dest_service_fid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginRequest::clear_dest_service_fid() {
  if (dest_service_fid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dest_service_fid_->clear();
  }
  clear_has_dest_service_fid();
}
inline const ::std::string& LoginRequest::dest_service_fid() const {
  // @@protoc_insertion_point(field_get:boyim_proto.LoginRequest.dest_service_fid)
  return *dest_service_fid_;
}
inline void LoginRequest::set_dest_service_fid(const ::std::string& value) {
  set_has_dest_service_fid();
  if (dest_service_fid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dest_service_fid_ = new ::std::string;
  }
  dest_service_fid_->assign(value);
  // @@protoc_insertion_point(field_set:boyim_proto.LoginRequest.dest_service_fid)
}
inline void LoginRequest::set_dest_service_fid(const char* value) {
  set_has_dest_service_fid();
  if (dest_service_fid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dest_service_fid_ = new ::std::string;
  }
  dest_service_fid_->assign(value);
  // @@protoc_insertion_point(field_set_char:boyim_proto.LoginRequest.dest_service_fid)
}
inline void LoginRequest::set_dest_service_fid(const char* value, size_t size) {
  set_has_dest_service_fid();
  if (dest_service_fid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dest_service_fid_ = new ::std::string;
  }
  dest_service_fid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:boyim_proto.LoginRequest.dest_service_fid)
}
inline ::std::string* LoginRequest::mutable_dest_service_fid() {
  set_has_dest_service_fid();
  if (dest_service_fid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dest_service_fid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:boyim_proto.LoginRequest.dest_service_fid)
  return dest_service_fid_;
}
inline ::std::string* LoginRequest::release_dest_service_fid() {
  clear_has_dest_service_fid();
  if (dest_service_fid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = dest_service_fid_;
    dest_service_fid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoginRequest::set_allocated_dest_service_fid(::std::string* dest_service_fid) {
  if (dest_service_fid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete dest_service_fid_;
  }
  if (dest_service_fid) {
    set_has_dest_service_fid();
    dest_service_fid_ = dest_service_fid;
  } else {
    clear_has_dest_service_fid();
    dest_service_fid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:boyim_proto.LoginRequest.dest_service_fid)
}

// optional string from_service_fid = 4;
inline bool LoginRequest::has_from_service_fid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginRequest::set_has_from_service_fid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginRequest::clear_has_from_service_fid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginRequest::clear_from_service_fid() {
  if (from_service_fid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    from_service_fid_->clear();
  }
  clear_has_from_service_fid();
}
inline const ::std::string& LoginRequest::from_service_fid() const {
  // @@protoc_insertion_point(field_get:boyim_proto.LoginRequest.from_service_fid)
  return *from_service_fid_;
}
inline void LoginRequest::set_from_service_fid(const ::std::string& value) {
  set_has_from_service_fid();
  if (from_service_fid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    from_service_fid_ = new ::std::string;
  }
  from_service_fid_->assign(value);
  // @@protoc_insertion_point(field_set:boyim_proto.LoginRequest.from_service_fid)
}
inline void LoginRequest::set_from_service_fid(const char* value) {
  set_has_from_service_fid();
  if (from_service_fid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    from_service_fid_ = new ::std::string;
  }
  from_service_fid_->assign(value);
  // @@protoc_insertion_point(field_set_char:boyim_proto.LoginRequest.from_service_fid)
}
inline void LoginRequest::set_from_service_fid(const char* value, size_t size) {
  set_has_from_service_fid();
  if (from_service_fid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    from_service_fid_ = new ::std::string;
  }
  from_service_fid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:boyim_proto.LoginRequest.from_service_fid)
}
inline ::std::string* LoginRequest::mutable_from_service_fid() {
  set_has_from_service_fid();
  if (from_service_fid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    from_service_fid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:boyim_proto.LoginRequest.from_service_fid)
  return from_service_fid_;
}
inline ::std::string* LoginRequest::release_from_service_fid() {
  clear_has_from_service_fid();
  if (from_service_fid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = from_service_fid_;
    from_service_fid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoginRequest::set_allocated_from_service_fid(::std::string* from_service_fid) {
  if (from_service_fid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete from_service_fid_;
  }
  if (from_service_fid) {
    set_has_from_service_fid();
    from_service_fid_ = from_service_fid;
  } else {
    clear_has_from_service_fid();
    from_service_fid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:boyim_proto.LoginRequest.from_service_fid)
}

// -------------------------------------------------------------------

// LoginResponse

// required int32 code = 1;
inline bool LoginResponse::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginResponse::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginResponse::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginResponse::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 LoginResponse::code() const {
  // @@protoc_insertion_point(field_get:boyim_proto.LoginResponse.code)
  return code_;
}
inline void LoginResponse::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
  // @@protoc_insertion_point(field_set:boyim_proto.LoginResponse.code)
}

// optional string session_id = 2;
inline bool LoginResponse::has_session_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginResponse::set_has_session_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginResponse::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginResponse::clear_session_id() {
  if (session_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_id_->clear();
  }
  clear_has_session_id();
}
inline const ::std::string& LoginResponse::session_id() const {
  // @@protoc_insertion_point(field_get:boyim_proto.LoginResponse.session_id)
  return *session_id_;
}
inline void LoginResponse::set_session_id(const ::std::string& value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
  // @@protoc_insertion_point(field_set:boyim_proto.LoginResponse.session_id)
}
inline void LoginResponse::set_session_id(const char* value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:boyim_proto.LoginResponse.session_id)
}
inline void LoginResponse::set_session_id(const char* value, size_t size) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:boyim_proto.LoginResponse.session_id)
}
inline ::std::string* LoginResponse::mutable_session_id() {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:boyim_proto.LoginResponse.session_id)
  return session_id_;
}
inline ::std::string* LoginResponse::release_session_id() {
  clear_has_session_id();
  if (session_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = session_id_;
    session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoginResponse::set_allocated_session_id(::std::string* session_id) {
  if (session_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete session_id_;
  }
  if (session_id) {
    set_has_session_id();
    session_id_ = session_id;
  } else {
    clear_has_session_id();
    session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:boyim_proto.LoginResponse.session_id)
}

// optional string role = 3;
inline bool LoginResponse::has_role() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginResponse::set_has_role() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginResponse::clear_has_role() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginResponse::clear_role() {
  if (role_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    role_->clear();
  }
  clear_has_role();
}
inline const ::std::string& LoginResponse::role() const {
  // @@protoc_insertion_point(field_get:boyim_proto.LoginResponse.role)
  return *role_;
}
inline void LoginResponse::set_role(const ::std::string& value) {
  set_has_role();
  if (role_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    role_ = new ::std::string;
  }
  role_->assign(value);
  // @@protoc_insertion_point(field_set:boyim_proto.LoginResponse.role)
}
inline void LoginResponse::set_role(const char* value) {
  set_has_role();
  if (role_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    role_ = new ::std::string;
  }
  role_->assign(value);
  // @@protoc_insertion_point(field_set_char:boyim_proto.LoginResponse.role)
}
inline void LoginResponse::set_role(const char* value, size_t size) {
  set_has_role();
  if (role_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    role_ = new ::std::string;
  }
  role_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:boyim_proto.LoginResponse.role)
}
inline ::std::string* LoginResponse::mutable_role() {
  set_has_role();
  if (role_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    role_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:boyim_proto.LoginResponse.role)
  return role_;
}
inline ::std::string* LoginResponse::release_role() {
  clear_has_role();
  if (role_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = role_;
    role_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoginResponse::set_allocated_role(::std::string* role) {
  if (role_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete role_;
  }
  if (role) {
    set_has_role();
    role_ = role;
  } else {
    clear_has_role();
    role_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:boyim_proto.LoginResponse.role)
}

// optional string return_msg = 4;
inline bool LoginResponse::has_return_msg() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginResponse::set_has_return_msg() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginResponse::clear_has_return_msg() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginResponse::clear_return_msg() {
  if (return_msg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return_msg_->clear();
  }
  clear_has_return_msg();
}
inline const ::std::string& LoginResponse::return_msg() const {
  // @@protoc_insertion_point(field_get:boyim_proto.LoginResponse.return_msg)
  return *return_msg_;
}
inline void LoginResponse::set_return_msg(const ::std::string& value) {
  set_has_return_msg();
  if (return_msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return_msg_ = new ::std::string;
  }
  return_msg_->assign(value);
  // @@protoc_insertion_point(field_set:boyim_proto.LoginResponse.return_msg)
}
inline void LoginResponse::set_return_msg(const char* value) {
  set_has_return_msg();
  if (return_msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return_msg_ = new ::std::string;
  }
  return_msg_->assign(value);
  // @@protoc_insertion_point(field_set_char:boyim_proto.LoginResponse.return_msg)
}
inline void LoginResponse::set_return_msg(const char* value, size_t size) {
  set_has_return_msg();
  if (return_msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return_msg_ = new ::std::string;
  }
  return_msg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:boyim_proto.LoginResponse.return_msg)
}
inline ::std::string* LoginResponse::mutable_return_msg() {
  set_has_return_msg();
  if (return_msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return_msg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:boyim_proto.LoginResponse.return_msg)
  return return_msg_;
}
inline ::std::string* LoginResponse::release_return_msg() {
  clear_has_return_msg();
  if (return_msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = return_msg_;
    return_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoginResponse::set_allocated_return_msg(::std::string* return_msg) {
  if (return_msg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete return_msg_;
  }
  if (return_msg) {
    set_has_return_msg();
    return_msg_ = return_msg;
  } else {
    clear_has_return_msg();
    return_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:boyim_proto.LoginResponse.return_msg)
}

// optional string service_gid = 11;
inline bool LoginResponse::has_service_gid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LoginResponse::set_has_service_gid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LoginResponse::clear_has_service_gid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LoginResponse::clear_service_gid() {
  if (service_gid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_gid_->clear();
  }
  clear_has_service_gid();
}
inline const ::std::string& LoginResponse::service_gid() const {
  // @@protoc_insertion_point(field_get:boyim_proto.LoginResponse.service_gid)
  return *service_gid_;
}
inline void LoginResponse::set_service_gid(const ::std::string& value) {
  set_has_service_gid();
  if (service_gid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_gid_ = new ::std::string;
  }
  service_gid_->assign(value);
  // @@protoc_insertion_point(field_set:boyim_proto.LoginResponse.service_gid)
}
inline void LoginResponse::set_service_gid(const char* value) {
  set_has_service_gid();
  if (service_gid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_gid_ = new ::std::string;
  }
  service_gid_->assign(value);
  // @@protoc_insertion_point(field_set_char:boyim_proto.LoginResponse.service_gid)
}
inline void LoginResponse::set_service_gid(const char* value, size_t size) {
  set_has_service_gid();
  if (service_gid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_gid_ = new ::std::string;
  }
  service_gid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:boyim_proto.LoginResponse.service_gid)
}
inline ::std::string* LoginResponse::mutable_service_gid() {
  set_has_service_gid();
  if (service_gid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_gid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:boyim_proto.LoginResponse.service_gid)
  return service_gid_;
}
inline ::std::string* LoginResponse::release_service_gid() {
  clear_has_service_gid();
  if (service_gid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = service_gid_;
    service_gid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoginResponse::set_allocated_service_gid(::std::string* service_gid) {
  if (service_gid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete service_gid_;
  }
  if (service_gid) {
    set_has_service_gid();
    service_gid_ = service_gid;
  } else {
    clear_has_service_gid();
    service_gid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:boyim_proto.LoginResponse.service_gid)
}

// optional string service_site_id = 12;
inline bool LoginResponse::has_service_site_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LoginResponse::set_has_service_site_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LoginResponse::clear_has_service_site_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LoginResponse::clear_service_site_id() {
  if (service_site_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_site_id_->clear();
  }
  clear_has_service_site_id();
}
inline const ::std::string& LoginResponse::service_site_id() const {
  // @@protoc_insertion_point(field_get:boyim_proto.LoginResponse.service_site_id)
  return *service_site_id_;
}
inline void LoginResponse::set_service_site_id(const ::std::string& value) {
  set_has_service_site_id();
  if (service_site_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_site_id_ = new ::std::string;
  }
  service_site_id_->assign(value);
  // @@protoc_insertion_point(field_set:boyim_proto.LoginResponse.service_site_id)
}
inline void LoginResponse::set_service_site_id(const char* value) {
  set_has_service_site_id();
  if (service_site_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_site_id_ = new ::std::string;
  }
  service_site_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:boyim_proto.LoginResponse.service_site_id)
}
inline void LoginResponse::set_service_site_id(const char* value, size_t size) {
  set_has_service_site_id();
  if (service_site_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_site_id_ = new ::std::string;
  }
  service_site_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:boyim_proto.LoginResponse.service_site_id)
}
inline ::std::string* LoginResponse::mutable_service_site_id() {
  set_has_service_site_id();
  if (service_site_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_site_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:boyim_proto.LoginResponse.service_site_id)
  return service_site_id_;
}
inline ::std::string* LoginResponse::release_service_site_id() {
  clear_has_service_site_id();
  if (service_site_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = service_site_id_;
    service_site_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoginResponse::set_allocated_service_site_id(::std::string* service_site_id) {
  if (service_site_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete service_site_id_;
  }
  if (service_site_id) {
    set_has_service_site_id();
    service_site_id_ = service_site_id;
  } else {
    clear_has_service_site_id();
    service_site_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:boyim_proto.LoginResponse.service_site_id)
}

// optional string service_station_id = 13;
inline bool LoginResponse::has_service_station_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LoginResponse::set_has_service_station_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LoginResponse::clear_has_service_station_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LoginResponse::clear_service_station_id() {
  if (service_station_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_station_id_->clear();
  }
  clear_has_service_station_id();
}
inline const ::std::string& LoginResponse::service_station_id() const {
  // @@protoc_insertion_point(field_get:boyim_proto.LoginResponse.service_station_id)
  return *service_station_id_;
}
inline void LoginResponse::set_service_station_id(const ::std::string& value) {
  set_has_service_station_id();
  if (service_station_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_station_id_ = new ::std::string;
  }
  service_station_id_->assign(value);
  // @@protoc_insertion_point(field_set:boyim_proto.LoginResponse.service_station_id)
}
inline void LoginResponse::set_service_station_id(const char* value) {
  set_has_service_station_id();
  if (service_station_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_station_id_ = new ::std::string;
  }
  service_station_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:boyim_proto.LoginResponse.service_station_id)
}
inline void LoginResponse::set_service_station_id(const char* value, size_t size) {
  set_has_service_station_id();
  if (service_station_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_station_id_ = new ::std::string;
  }
  service_station_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:boyim_proto.LoginResponse.service_station_id)
}
inline ::std::string* LoginResponse::mutable_service_station_id() {
  set_has_service_station_id();
  if (service_station_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_station_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:boyim_proto.LoginResponse.service_station_id)
  return service_station_id_;
}
inline ::std::string* LoginResponse::release_service_station_id() {
  clear_has_service_station_id();
  if (service_station_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = service_station_id_;
    service_station_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoginResponse::set_allocated_service_station_id(::std::string* service_station_id) {
  if (service_station_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete service_station_id_;
  }
  if (service_station_id) {
    set_has_service_station_id();
    service_station_id_ = service_station_id;
  } else {
    clear_has_service_station_id();
    service_station_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:boyim_proto.LoginResponse.service_station_id)
}

// optional int32 wait_count = 14;
inline bool LoginResponse::has_wait_count() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LoginResponse::set_has_wait_count() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LoginResponse::clear_has_wait_count() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LoginResponse::clear_wait_count() {
  wait_count_ = 0;
  clear_has_wait_count();
}
inline ::google::protobuf::int32 LoginResponse::wait_count() const {
  // @@protoc_insertion_point(field_get:boyim_proto.LoginResponse.wait_count)
  return wait_count_;
}
inline void LoginResponse::set_wait_count(::google::protobuf::int32 value) {
  set_has_wait_count();
  wait_count_ = value;
  // @@protoc_insertion_point(field_set:boyim_proto.LoginResponse.wait_count)
}

// repeated string serve_apps = 21;
inline int LoginResponse::serve_apps_size() const {
  return serve_apps_.size();
}
inline void LoginResponse::clear_serve_apps() {
  serve_apps_.Clear();
}
inline const ::std::string& LoginResponse::serve_apps(int index) const {
  // @@protoc_insertion_point(field_get:boyim_proto.LoginResponse.serve_apps)
  return serve_apps_.Get(index);
}
inline ::std::string* LoginResponse::mutable_serve_apps(int index) {
  // @@protoc_insertion_point(field_mutable:boyim_proto.LoginResponse.serve_apps)
  return serve_apps_.Mutable(index);
}
inline void LoginResponse::set_serve_apps(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:boyim_proto.LoginResponse.serve_apps)
  serve_apps_.Mutable(index)->assign(value);
}
inline void LoginResponse::set_serve_apps(int index, const char* value) {
  serve_apps_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:boyim_proto.LoginResponse.serve_apps)
}
inline void LoginResponse::set_serve_apps(int index, const char* value, size_t size) {
  serve_apps_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:boyim_proto.LoginResponse.serve_apps)
}
inline ::std::string* LoginResponse::add_serve_apps() {
  return serve_apps_.Add();
}
inline void LoginResponse::add_serve_apps(const ::std::string& value) {
  serve_apps_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:boyim_proto.LoginResponse.serve_apps)
}
inline void LoginResponse::add_serve_apps(const char* value) {
  serve_apps_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:boyim_proto.LoginResponse.serve_apps)
}
inline void LoginResponse::add_serve_apps(const char* value, size_t size) {
  serve_apps_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:boyim_proto.LoginResponse.serve_apps)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
LoginResponse::serve_apps() const {
  // @@protoc_insertion_point(field_list:boyim_proto.LoginResponse.serve_apps)
  return serve_apps_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
LoginResponse::mutable_serve_apps() {
  // @@protoc_insertion_point(field_mutable_list:boyim_proto.LoginResponse.serve_apps)
  return &serve_apps_;
}

// -------------------------------------------------------------------

// ServiceReady

// required .boyim_proto.Header header = 1;
inline bool ServiceReady::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServiceReady::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServiceReady::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServiceReady::clear_header() {
  if (header_ != NULL) header_->::boyim_proto::Header::Clear();
  clear_has_header();
}
inline const ::boyim_proto::Header& ServiceReady::header() const {
  // @@protoc_insertion_point(field_get:boyim_proto.ServiceReady.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::boyim_proto::Header* ServiceReady::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::boyim_proto::Header;
  // @@protoc_insertion_point(field_mutable:boyim_proto.ServiceReady.header)
  return header_;
}
inline ::boyim_proto::Header* ServiceReady::release_header() {
  clear_has_header();
  ::boyim_proto::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void ServiceReady::set_allocated_header(::boyim_proto::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:boyim_proto.ServiceReady.header)
}

// -------------------------------------------------------------------

// ServiceReadyResponse

// required int32 code = 1;
inline bool ServiceReadyResponse::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServiceReadyResponse::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServiceReadyResponse::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServiceReadyResponse::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 ServiceReadyResponse::code() const {
  // @@protoc_insertion_point(field_get:boyim_proto.ServiceReadyResponse.code)
  return code_;
}
inline void ServiceReadyResponse::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
  // @@protoc_insertion_point(field_set:boyim_proto.ServiceReadyResponse.code)
}

// optional string client_fid = 2;
inline bool ServiceReadyResponse::has_client_fid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServiceReadyResponse::set_has_client_fid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServiceReadyResponse::clear_has_client_fid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServiceReadyResponse::clear_client_fid() {
  if (client_fid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_fid_->clear();
  }
  clear_has_client_fid();
}
inline const ::std::string& ServiceReadyResponse::client_fid() const {
  // @@protoc_insertion_point(field_get:boyim_proto.ServiceReadyResponse.client_fid)
  return *client_fid_;
}
inline void ServiceReadyResponse::set_client_fid(const ::std::string& value) {
  set_has_client_fid();
  if (client_fid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_fid_ = new ::std::string;
  }
  client_fid_->assign(value);
  // @@protoc_insertion_point(field_set:boyim_proto.ServiceReadyResponse.client_fid)
}
inline void ServiceReadyResponse::set_client_fid(const char* value) {
  set_has_client_fid();
  if (client_fid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_fid_ = new ::std::string;
  }
  client_fid_->assign(value);
  // @@protoc_insertion_point(field_set_char:boyim_proto.ServiceReadyResponse.client_fid)
}
inline void ServiceReadyResponse::set_client_fid(const char* value, size_t size) {
  set_has_client_fid();
  if (client_fid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_fid_ = new ::std::string;
  }
  client_fid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:boyim_proto.ServiceReadyResponse.client_fid)
}
inline ::std::string* ServiceReadyResponse::mutable_client_fid() {
  set_has_client_fid();
  if (client_fid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_fid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:boyim_proto.ServiceReadyResponse.client_fid)
  return client_fid_;
}
inline ::std::string* ServiceReadyResponse::release_client_fid() {
  clear_has_client_fid();
  if (client_fid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = client_fid_;
    client_fid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ServiceReadyResponse::set_allocated_client_fid(::std::string* client_fid) {
  if (client_fid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete client_fid_;
  }
  if (client_fid) {
    set_has_client_fid();
    client_fid_ = client_fid;
  } else {
    clear_has_client_fid();
    client_fid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:boyim_proto.ServiceReadyResponse.client_fid)
}

// optional int64 client_login_clock = 3;
inline bool ServiceReadyResponse::has_client_login_clock() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServiceReadyResponse::set_has_client_login_clock() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServiceReadyResponse::clear_has_client_login_clock() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServiceReadyResponse::clear_client_login_clock() {
  client_login_clock_ = GOOGLE_LONGLONG(0);
  clear_has_client_login_clock();
}
inline ::google::protobuf::int64 ServiceReadyResponse::client_login_clock() const {
  // @@protoc_insertion_point(field_get:boyim_proto.ServiceReadyResponse.client_login_clock)
  return client_login_clock_;
}
inline void ServiceReadyResponse::set_client_login_clock(::google::protobuf::int64 value) {
  set_has_client_login_clock();
  client_login_clock_ = value;
  // @@protoc_insertion_point(field_set:boyim_proto.ServiceReadyResponse.client_login_clock)
}

// optional int32 wait_count = 4;
inline bool ServiceReadyResponse::has_wait_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServiceReadyResponse::set_has_wait_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ServiceReadyResponse::clear_has_wait_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ServiceReadyResponse::clear_wait_count() {
  wait_count_ = 0;
  clear_has_wait_count();
}
inline ::google::protobuf::int32 ServiceReadyResponse::wait_count() const {
  // @@protoc_insertion_point(field_get:boyim_proto.ServiceReadyResponse.wait_count)
  return wait_count_;
}
inline void ServiceReadyResponse::set_wait_count(::google::protobuf::int32 value) {
  set_has_wait_count();
  wait_count_ = value;
  // @@protoc_insertion_point(field_set:boyim_proto.ServiceReadyResponse.wait_count)
}

// repeated .boyim_proto.ClientEntry client_entries = 5;
inline int ServiceReadyResponse::client_entries_size() const {
  return client_entries_.size();
}
inline void ServiceReadyResponse::clear_client_entries() {
  client_entries_.Clear();
}
inline const ::boyim_proto::ClientEntry& ServiceReadyResponse::client_entries(int index) const {
  // @@protoc_insertion_point(field_get:boyim_proto.ServiceReadyResponse.client_entries)
  return client_entries_.Get(index);
}
inline ::boyim_proto::ClientEntry* ServiceReadyResponse::mutable_client_entries(int index) {
  // @@protoc_insertion_point(field_mutable:boyim_proto.ServiceReadyResponse.client_entries)
  return client_entries_.Mutable(index);
}
inline ::boyim_proto::ClientEntry* ServiceReadyResponse::add_client_entries() {
  // @@protoc_insertion_point(field_add:boyim_proto.ServiceReadyResponse.client_entries)
  return client_entries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::boyim_proto::ClientEntry >&
ServiceReadyResponse::client_entries() const {
  // @@protoc_insertion_point(field_list:boyim_proto.ServiceReadyResponse.client_entries)
  return client_entries_;
}
inline ::google::protobuf::RepeatedPtrField< ::boyim_proto::ClientEntry >*
ServiceReadyResponse::mutable_client_entries() {
  // @@protoc_insertion_point(field_mutable_list:boyim_proto.ServiceReadyResponse.client_entries)
  return &client_entries_;
}

// -------------------------------------------------------------------

// ClientEntry

// required string client_fid = 1;
inline bool ClientEntry::has_client_fid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientEntry::set_has_client_fid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientEntry::clear_has_client_fid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientEntry::clear_client_fid() {
  if (client_fid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_fid_->clear();
  }
  clear_has_client_fid();
}
inline const ::std::string& ClientEntry::client_fid() const {
  // @@protoc_insertion_point(field_get:boyim_proto.ClientEntry.client_fid)
  return *client_fid_;
}
inline void ClientEntry::set_client_fid(const ::std::string& value) {
  set_has_client_fid();
  if (client_fid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_fid_ = new ::std::string;
  }
  client_fid_->assign(value);
  // @@protoc_insertion_point(field_set:boyim_proto.ClientEntry.client_fid)
}
inline void ClientEntry::set_client_fid(const char* value) {
  set_has_client_fid();
  if (client_fid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_fid_ = new ::std::string;
  }
  client_fid_->assign(value);
  // @@protoc_insertion_point(field_set_char:boyim_proto.ClientEntry.client_fid)
}
inline void ClientEntry::set_client_fid(const char* value, size_t size) {
  set_has_client_fid();
  if (client_fid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_fid_ = new ::std::string;
  }
  client_fid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:boyim_proto.ClientEntry.client_fid)
}
inline ::std::string* ClientEntry::mutable_client_fid() {
  set_has_client_fid();
  if (client_fid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_fid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:boyim_proto.ClientEntry.client_fid)
  return client_fid_;
}
inline ::std::string* ClientEntry::release_client_fid() {
  clear_has_client_fid();
  if (client_fid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = client_fid_;
    client_fid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ClientEntry::set_allocated_client_fid(::std::string* client_fid) {
  if (client_fid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete client_fid_;
  }
  if (client_fid) {
    set_has_client_fid();
    client_fid_ = client_fid;
  } else {
    clear_has_client_fid();
    client_fid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:boyim_proto.ClientEntry.client_fid)
}

// required int64 start_clock = 2;
inline bool ClientEntry::has_start_clock() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientEntry::set_has_start_clock() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientEntry::clear_has_start_clock() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientEntry::clear_start_clock() {
  start_clock_ = GOOGLE_LONGLONG(0);
  clear_has_start_clock();
}
inline ::google::protobuf::int64 ClientEntry::start_clock() const {
  // @@protoc_insertion_point(field_get:boyim_proto.ClientEntry.start_clock)
  return start_clock_;
}
inline void ClientEntry::set_start_clock(::google::protobuf::int64 value) {
  set_has_start_clock();
  start_clock_ = value;
  // @@protoc_insertion_point(field_set:boyim_proto.ClientEntry.start_clock)
}

// -------------------------------------------------------------------

// ChatReadyRequest

// required .boyim_proto.Header header = 1;
inline bool ChatReadyRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChatReadyRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChatReadyRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChatReadyRequest::clear_header() {
  if (header_ != NULL) header_->::boyim_proto::Header::Clear();
  clear_has_header();
}
inline const ::boyim_proto::Header& ChatReadyRequest::header() const {
  // @@protoc_insertion_point(field_get:boyim_proto.ChatReadyRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::boyim_proto::Header* ChatReadyRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::boyim_proto::Header;
  // @@protoc_insertion_point(field_mutable:boyim_proto.ChatReadyRequest.header)
  return header_;
}
inline ::boyim_proto::Header* ChatReadyRequest::release_header() {
  clear_has_header();
  ::boyim_proto::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void ChatReadyRequest::set_allocated_header(::boyim_proto::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:boyim_proto.ChatReadyRequest.header)
}

// required string session_id = 2;
inline bool ChatReadyRequest::has_session_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChatReadyRequest::set_has_session_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChatReadyRequest::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChatReadyRequest::clear_session_id() {
  if (session_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_id_->clear();
  }
  clear_has_session_id();
}
inline const ::std::string& ChatReadyRequest::session_id() const {
  // @@protoc_insertion_point(field_get:boyim_proto.ChatReadyRequest.session_id)
  return *session_id_;
}
inline void ChatReadyRequest::set_session_id(const ::std::string& value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
  // @@protoc_insertion_point(field_set:boyim_proto.ChatReadyRequest.session_id)
}
inline void ChatReadyRequest::set_session_id(const char* value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:boyim_proto.ChatReadyRequest.session_id)
}
inline void ChatReadyRequest::set_session_id(const char* value, size_t size) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:boyim_proto.ChatReadyRequest.session_id)
}
inline ::std::string* ChatReadyRequest::mutable_session_id() {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:boyim_proto.ChatReadyRequest.session_id)
  return session_id_;
}
inline ::std::string* ChatReadyRequest::release_session_id() {
  clear_has_session_id();
  if (session_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = session_id_;
    session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ChatReadyRequest::set_allocated_session_id(::std::string* session_id) {
  if (session_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete session_id_;
  }
  if (session_id) {
    set_has_session_id();
    session_id_ = session_id;
  } else {
    clear_has_session_id();
    session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:boyim_proto.ChatReadyRequest.session_id)
}

// required string client_info = 3;
inline bool ChatReadyRequest::has_client_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChatReadyRequest::set_has_client_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChatReadyRequest::clear_has_client_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChatReadyRequest::clear_client_info() {
  if (client_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_info_->clear();
  }
  clear_has_client_info();
}
inline const ::std::string& ChatReadyRequest::client_info() const {
  // @@protoc_insertion_point(field_get:boyim_proto.ChatReadyRequest.client_info)
  return *client_info_;
}
inline void ChatReadyRequest::set_client_info(const ::std::string& value) {
  set_has_client_info();
  if (client_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_info_ = new ::std::string;
  }
  client_info_->assign(value);
  // @@protoc_insertion_point(field_set:boyim_proto.ChatReadyRequest.client_info)
}
inline void ChatReadyRequest::set_client_info(const char* value) {
  set_has_client_info();
  if (client_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_info_ = new ::std::string;
  }
  client_info_->assign(value);
  // @@protoc_insertion_point(field_set_char:boyim_proto.ChatReadyRequest.client_info)
}
inline void ChatReadyRequest::set_client_info(const char* value, size_t size) {
  set_has_client_info();
  if (client_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_info_ = new ::std::string;
  }
  client_info_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:boyim_proto.ChatReadyRequest.client_info)
}
inline ::std::string* ChatReadyRequest::mutable_client_info() {
  set_has_client_info();
  if (client_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_info_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:boyim_proto.ChatReadyRequest.client_info)
  return client_info_;
}
inline ::std::string* ChatReadyRequest::release_client_info() {
  clear_has_client_info();
  if (client_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = client_info_;
    client_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ChatReadyRequest::set_allocated_client_info(::std::string* client_info) {
  if (client_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete client_info_;
  }
  if (client_info) {
    set_has_client_info();
    client_info_ = client_info;
  } else {
    clear_has_client_info();
    client_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:boyim_proto.ChatReadyRequest.client_info)
}

// -------------------------------------------------------------------

// ChatReadyResponse

// required .boyim_proto.Header header = 1;
inline bool ChatReadyResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChatReadyResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChatReadyResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChatReadyResponse::clear_header() {
  if (header_ != NULL) header_->::boyim_proto::Header::Clear();
  clear_has_header();
}
inline const ::boyim_proto::Header& ChatReadyResponse::header() const {
  // @@protoc_insertion_point(field_get:boyim_proto.ChatReadyResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::boyim_proto::Header* ChatReadyResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::boyim_proto::Header;
  // @@protoc_insertion_point(field_mutable:boyim_proto.ChatReadyResponse.header)
  return header_;
}
inline ::boyim_proto::Header* ChatReadyResponse::release_header() {
  clear_has_header();
  ::boyim_proto::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void ChatReadyResponse::set_allocated_header(::boyim_proto::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:boyim_proto.ChatReadyResponse.header)
}

// required string session_id = 2;
inline bool ChatReadyResponse::has_session_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChatReadyResponse::set_has_session_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChatReadyResponse::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChatReadyResponse::clear_session_id() {
  if (session_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_id_->clear();
  }
  clear_has_session_id();
}
inline const ::std::string& ChatReadyResponse::session_id() const {
  // @@protoc_insertion_point(field_get:boyim_proto.ChatReadyResponse.session_id)
  return *session_id_;
}
inline void ChatReadyResponse::set_session_id(const ::std::string& value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
  // @@protoc_insertion_point(field_set:boyim_proto.ChatReadyResponse.session_id)
}
inline void ChatReadyResponse::set_session_id(const char* value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:boyim_proto.ChatReadyResponse.session_id)
}
inline void ChatReadyResponse::set_session_id(const char* value, size_t size) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:boyim_proto.ChatReadyResponse.session_id)
}
inline ::std::string* ChatReadyResponse::mutable_session_id() {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:boyim_proto.ChatReadyResponse.session_id)
  return session_id_;
}
inline ::std::string* ChatReadyResponse::release_session_id() {
  clear_has_session_id();
  if (session_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = session_id_;
    session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ChatReadyResponse::set_allocated_session_id(::std::string* session_id) {
  if (session_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete session_id_;
  }
  if (session_id) {
    set_has_session_id();
    session_id_ = session_id;
  } else {
    clear_has_session_id();
    session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:boyim_proto.ChatReadyResponse.session_id)
}

// required int32 code = 3;
inline bool ChatReadyResponse::has_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChatReadyResponse::set_has_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChatReadyResponse::clear_has_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChatReadyResponse::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 ChatReadyResponse::code() const {
  // @@protoc_insertion_point(field_get:boyim_proto.ChatReadyResponse.code)
  return code_;
}
inline void ChatReadyResponse::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
  // @@protoc_insertion_point(field_set:boyim_proto.ChatReadyResponse.code)
}

// optional string service_info = 4;
inline bool ChatReadyResponse::has_service_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChatReadyResponse::set_has_service_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ChatReadyResponse::clear_has_service_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ChatReadyResponse::clear_service_info() {
  if (service_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_info_->clear();
  }
  clear_has_service_info();
}
inline const ::std::string& ChatReadyResponse::service_info() const {
  // @@protoc_insertion_point(field_get:boyim_proto.ChatReadyResponse.service_info)
  return *service_info_;
}
inline void ChatReadyResponse::set_service_info(const ::std::string& value) {
  set_has_service_info();
  if (service_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_info_ = new ::std::string;
  }
  service_info_->assign(value);
  // @@protoc_insertion_point(field_set:boyim_proto.ChatReadyResponse.service_info)
}
inline void ChatReadyResponse::set_service_info(const char* value) {
  set_has_service_info();
  if (service_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_info_ = new ::std::string;
  }
  service_info_->assign(value);
  // @@protoc_insertion_point(field_set_char:boyim_proto.ChatReadyResponse.service_info)
}
inline void ChatReadyResponse::set_service_info(const char* value, size_t size) {
  set_has_service_info();
  if (service_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_info_ = new ::std::string;
  }
  service_info_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:boyim_proto.ChatReadyResponse.service_info)
}
inline ::std::string* ChatReadyResponse::mutable_service_info() {
  set_has_service_info();
  if (service_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_info_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:boyim_proto.ChatReadyResponse.service_info)
  return service_info_;
}
inline ::std::string* ChatReadyResponse::release_service_info() {
  clear_has_service_info();
  if (service_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = service_info_;
    service_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ChatReadyResponse::set_allocated_service_info(::std::string* service_info) {
  if (service_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete service_info_;
  }
  if (service_info) {
    set_has_service_info();
    service_info_ = service_info;
  } else {
    clear_has_service_info();
    service_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:boyim_proto.ChatReadyResponse.service_info)
}

// -------------------------------------------------------------------

// ChatMessage

// required .boyim_proto.Header header = 1;
inline bool ChatMessage::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChatMessage::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChatMessage::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChatMessage::clear_header() {
  if (header_ != NULL) header_->::boyim_proto::Header::Clear();
  clear_has_header();
}
inline const ::boyim_proto::Header& ChatMessage::header() const {
  // @@protoc_insertion_point(field_get:boyim_proto.ChatMessage.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::boyim_proto::Header* ChatMessage::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::boyim_proto::Header;
  // @@protoc_insertion_point(field_mutable:boyim_proto.ChatMessage.header)
  return header_;
}
inline ::boyim_proto::Header* ChatMessage::release_header() {
  clear_has_header();
  ::boyim_proto::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void ChatMessage::set_allocated_header(::boyim_proto::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:boyim_proto.ChatMessage.header)
}

// required string session_id = 2;
inline bool ChatMessage::has_session_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChatMessage::set_has_session_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChatMessage::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChatMessage::clear_session_id() {
  if (session_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_id_->clear();
  }
  clear_has_session_id();
}
inline const ::std::string& ChatMessage::session_id() const {
  // @@protoc_insertion_point(field_get:boyim_proto.ChatMessage.session_id)
  return *session_id_;
}
inline void ChatMessage::set_session_id(const ::std::string& value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
  // @@protoc_insertion_point(field_set:boyim_proto.ChatMessage.session_id)
}
inline void ChatMessage::set_session_id(const char* value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:boyim_proto.ChatMessage.session_id)
}
inline void ChatMessage::set_session_id(const char* value, size_t size) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:boyim_proto.ChatMessage.session_id)
}
inline ::std::string* ChatMessage::mutable_session_id() {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:boyim_proto.ChatMessage.session_id)
  return session_id_;
}
inline ::std::string* ChatMessage::release_session_id() {
  clear_has_session_id();
  if (session_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = session_id_;
    session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ChatMessage::set_allocated_session_id(::std::string* session_id) {
  if (session_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete session_id_;
  }
  if (session_id) {
    set_has_session_id();
    session_id_ = session_id;
  } else {
    clear_has_session_id();
    session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:boyim_proto.ChatMessage.session_id)
}

// required int64 seq_id = 3;
inline bool ChatMessage::has_seq_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChatMessage::set_has_seq_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChatMessage::clear_has_seq_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChatMessage::clear_seq_id() {
  seq_id_ = GOOGLE_LONGLONG(0);
  clear_has_seq_id();
}
inline ::google::protobuf::int64 ChatMessage::seq_id() const {
  // @@protoc_insertion_point(field_get:boyim_proto.ChatMessage.seq_id)
  return seq_id_;
}
inline void ChatMessage::set_seq_id(::google::protobuf::int64 value) {
  set_has_seq_id();
  seq_id_ = value;
  // @@protoc_insertion_point(field_set:boyim_proto.ChatMessage.seq_id)
}

// required string type = 4;
inline bool ChatMessage::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChatMessage::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ChatMessage::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ChatMessage::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& ChatMessage::type() const {
  // @@protoc_insertion_point(field_get:boyim_proto.ChatMessage.type)
  return *type_;
}
inline void ChatMessage::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:boyim_proto.ChatMessage.type)
}
inline void ChatMessage::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:boyim_proto.ChatMessage.type)
}
inline void ChatMessage::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:boyim_proto.ChatMessage.type)
}
inline ::std::string* ChatMessage::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:boyim_proto.ChatMessage.type)
  return type_;
}
inline ::std::string* ChatMessage::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ChatMessage::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:boyim_proto.ChatMessage.type)
}

// required string msg = 5;
inline bool ChatMessage::has_msg() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ChatMessage::set_has_msg() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ChatMessage::clear_has_msg() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ChatMessage::clear_msg() {
  if (msg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& ChatMessage::msg() const {
  // @@protoc_insertion_point(field_get:boyim_proto.ChatMessage.msg)
  return *msg_;
}
inline void ChatMessage::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
  // @@protoc_insertion_point(field_set:boyim_proto.ChatMessage.msg)
}
inline void ChatMessage::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
  // @@protoc_insertion_point(field_set_char:boyim_proto.ChatMessage.msg)
}
inline void ChatMessage::set_msg(const char* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:boyim_proto.ChatMessage.msg)
}
inline ::std::string* ChatMessage::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:boyim_proto.ChatMessage.msg)
  return msg_;
}
inline ::std::string* ChatMessage::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ChatMessage::set_allocated_msg(::std::string* msg) {
  if (msg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete msg_;
  }
  if (msg) {
    set_has_msg();
    msg_ = msg;
  } else {
    clear_has_msg();
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:boyim_proto.ChatMessage.msg)
}

// -------------------------------------------------------------------

// ChatMessageAck

// required .boyim_proto.Header header = 1;
inline bool ChatMessageAck::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChatMessageAck::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChatMessageAck::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChatMessageAck::clear_header() {
  if (header_ != NULL) header_->::boyim_proto::Header::Clear();
  clear_has_header();
}
inline const ::boyim_proto::Header& ChatMessageAck::header() const {
  // @@protoc_insertion_point(field_get:boyim_proto.ChatMessageAck.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::boyim_proto::Header* ChatMessageAck::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::boyim_proto::Header;
  // @@protoc_insertion_point(field_mutable:boyim_proto.ChatMessageAck.header)
  return header_;
}
inline ::boyim_proto::Header* ChatMessageAck::release_header() {
  clear_has_header();
  ::boyim_proto::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void ChatMessageAck::set_allocated_header(::boyim_proto::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:boyim_proto.ChatMessageAck.header)
}

// required string session_id = 2;
inline bool ChatMessageAck::has_session_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChatMessageAck::set_has_session_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChatMessageAck::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChatMessageAck::clear_session_id() {
  if (session_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_id_->clear();
  }
  clear_has_session_id();
}
inline const ::std::string& ChatMessageAck::session_id() const {
  // @@protoc_insertion_point(field_get:boyim_proto.ChatMessageAck.session_id)
  return *session_id_;
}
inline void ChatMessageAck::set_session_id(const ::std::string& value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
  // @@protoc_insertion_point(field_set:boyim_proto.ChatMessageAck.session_id)
}
inline void ChatMessageAck::set_session_id(const char* value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:boyim_proto.ChatMessageAck.session_id)
}
inline void ChatMessageAck::set_session_id(const char* value, size_t size) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:boyim_proto.ChatMessageAck.session_id)
}
inline ::std::string* ChatMessageAck::mutable_session_id() {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:boyim_proto.ChatMessageAck.session_id)
  return session_id_;
}
inline ::std::string* ChatMessageAck::release_session_id() {
  clear_has_session_id();
  if (session_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = session_id_;
    session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ChatMessageAck::set_allocated_session_id(::std::string* session_id) {
  if (session_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete session_id_;
  }
  if (session_id) {
    set_has_session_id();
    session_id_ = session_id;
  } else {
    clear_has_session_id();
    session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:boyim_proto.ChatMessageAck.session_id)
}

// repeated int64 seq_ids = 3;
inline int ChatMessageAck::seq_ids_size() const {
  return seq_ids_.size();
}
inline void ChatMessageAck::clear_seq_ids() {
  seq_ids_.Clear();
}
inline ::google::protobuf::int64 ChatMessageAck::seq_ids(int index) const {
  // @@protoc_insertion_point(field_get:boyim_proto.ChatMessageAck.seq_ids)
  return seq_ids_.Get(index);
}
inline void ChatMessageAck::set_seq_ids(int index, ::google::protobuf::int64 value) {
  seq_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:boyim_proto.ChatMessageAck.seq_ids)
}
inline void ChatMessageAck::add_seq_ids(::google::protobuf::int64 value) {
  seq_ids_.Add(value);
  // @@protoc_insertion_point(field_add:boyim_proto.ChatMessageAck.seq_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
ChatMessageAck::seq_ids() const {
  // @@protoc_insertion_point(field_list:boyim_proto.ChatMessageAck.seq_ids)
  return seq_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
ChatMessageAck::mutable_seq_ids() {
  // @@protoc_insertion_point(field_mutable_list:boyim_proto.ChatMessageAck.seq_ids)
  return &seq_ids_;
}

// -------------------------------------------------------------------

// FunctionMessage

// required .boyim_proto.Header header = 1;
inline bool FunctionMessage::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FunctionMessage::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FunctionMessage::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FunctionMessage::clear_header() {
  if (header_ != NULL) header_->::boyim_proto::Header::Clear();
  clear_has_header();
}
inline const ::boyim_proto::Header& FunctionMessage::header() const {
  // @@protoc_insertion_point(field_get:boyim_proto.FunctionMessage.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::boyim_proto::Header* FunctionMessage::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::boyim_proto::Header;
  // @@protoc_insertion_point(field_mutable:boyim_proto.FunctionMessage.header)
  return header_;
}
inline ::boyim_proto::Header* FunctionMessage::release_header() {
  clear_has_header();
  ::boyim_proto::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void FunctionMessage::set_allocated_header(::boyim_proto::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:boyim_proto.FunctionMessage.header)
}

// required string session_id = 2;
inline bool FunctionMessage::has_session_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FunctionMessage::set_has_session_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FunctionMessage::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FunctionMessage::clear_session_id() {
  if (session_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_id_->clear();
  }
  clear_has_session_id();
}
inline const ::std::string& FunctionMessage::session_id() const {
  // @@protoc_insertion_point(field_get:boyim_proto.FunctionMessage.session_id)
  return *session_id_;
}
inline void FunctionMessage::set_session_id(const ::std::string& value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
  // @@protoc_insertion_point(field_set:boyim_proto.FunctionMessage.session_id)
}
inline void FunctionMessage::set_session_id(const char* value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:boyim_proto.FunctionMessage.session_id)
}
inline void FunctionMessage::set_session_id(const char* value, size_t size) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:boyim_proto.FunctionMessage.session_id)
}
inline ::std::string* FunctionMessage::mutable_session_id() {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:boyim_proto.FunctionMessage.session_id)
  return session_id_;
}
inline ::std::string* FunctionMessage::release_session_id() {
  clear_has_session_id();
  if (session_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = session_id_;
    session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FunctionMessage::set_allocated_session_id(::std::string* session_id) {
  if (session_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete session_id_;
  }
  if (session_id) {
    set_has_session_id();
    session_id_ = session_id;
  } else {
    clear_has_session_id();
    session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:boyim_proto.FunctionMessage.session_id)
}

// required int64 seq_id = 3;
inline bool FunctionMessage::has_seq_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FunctionMessage::set_has_seq_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FunctionMessage::clear_has_seq_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FunctionMessage::clear_seq_id() {
  seq_id_ = GOOGLE_LONGLONG(0);
  clear_has_seq_id();
}
inline ::google::protobuf::int64 FunctionMessage::seq_id() const {
  // @@protoc_insertion_point(field_get:boyim_proto.FunctionMessage.seq_id)
  return seq_id_;
}
inline void FunctionMessage::set_seq_id(::google::protobuf::int64 value) {
  set_has_seq_id();
  seq_id_ = value;
  // @@protoc_insertion_point(field_set:boyim_proto.FunctionMessage.seq_id)
}

// required string function = 4;
inline bool FunctionMessage::has_function() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FunctionMessage::set_has_function() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FunctionMessage::clear_has_function() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FunctionMessage::clear_function() {
  if (function_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    function_->clear();
  }
  clear_has_function();
}
inline const ::std::string& FunctionMessage::function() const {
  // @@protoc_insertion_point(field_get:boyim_proto.FunctionMessage.function)
  return *function_;
}
inline void FunctionMessage::set_function(const ::std::string& value) {
  set_has_function();
  if (function_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    function_ = new ::std::string;
  }
  function_->assign(value);
  // @@protoc_insertion_point(field_set:boyim_proto.FunctionMessage.function)
}
inline void FunctionMessage::set_function(const char* value) {
  set_has_function();
  if (function_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    function_ = new ::std::string;
  }
  function_->assign(value);
  // @@protoc_insertion_point(field_set_char:boyim_proto.FunctionMessage.function)
}
inline void FunctionMessage::set_function(const char* value, size_t size) {
  set_has_function();
  if (function_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    function_ = new ::std::string;
  }
  function_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:boyim_proto.FunctionMessage.function)
}
inline ::std::string* FunctionMessage::mutable_function() {
  set_has_function();
  if (function_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    function_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:boyim_proto.FunctionMessage.function)
  return function_;
}
inline ::std::string* FunctionMessage::release_function() {
  clear_has_function();
  if (function_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = function_;
    function_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FunctionMessage::set_allocated_function(::std::string* function) {
  if (function_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete function_;
  }
  if (function) {
    set_has_function();
    function_ = function;
  } else {
    clear_has_function();
    function_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:boyim_proto.FunctionMessage.function)
}

// -------------------------------------------------------------------

// FunctionMessageResponse

// required int32 code = 1;
inline bool FunctionMessageResponse::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FunctionMessageResponse::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FunctionMessageResponse::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FunctionMessageResponse::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 FunctionMessageResponse::code() const {
  // @@protoc_insertion_point(field_get:boyim_proto.FunctionMessageResponse.code)
  return code_;
}
inline void FunctionMessageResponse::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
  // @@protoc_insertion_point(field_set:boyim_proto.FunctionMessageResponse.code)
}

// required string session_id = 2;
inline bool FunctionMessageResponse::has_session_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FunctionMessageResponse::set_has_session_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FunctionMessageResponse::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FunctionMessageResponse::clear_session_id() {
  if (session_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_id_->clear();
  }
  clear_has_session_id();
}
inline const ::std::string& FunctionMessageResponse::session_id() const {
  // @@protoc_insertion_point(field_get:boyim_proto.FunctionMessageResponse.session_id)
  return *session_id_;
}
inline void FunctionMessageResponse::set_session_id(const ::std::string& value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
  // @@protoc_insertion_point(field_set:boyim_proto.FunctionMessageResponse.session_id)
}
inline void FunctionMessageResponse::set_session_id(const char* value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:boyim_proto.FunctionMessageResponse.session_id)
}
inline void FunctionMessageResponse::set_session_id(const char* value, size_t size) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:boyim_proto.FunctionMessageResponse.session_id)
}
inline ::std::string* FunctionMessageResponse::mutable_session_id() {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:boyim_proto.FunctionMessageResponse.session_id)
  return session_id_;
}
inline ::std::string* FunctionMessageResponse::release_session_id() {
  clear_has_session_id();
  if (session_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = session_id_;
    session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FunctionMessageResponse::set_allocated_session_id(::std::string* session_id) {
  if (session_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete session_id_;
  }
  if (session_id) {
    set_has_session_id();
    session_id_ = session_id;
  } else {
    clear_has_session_id();
    session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:boyim_proto.FunctionMessageResponse.session_id)
}

// required int64 seq_id = 3;
inline bool FunctionMessageResponse::has_seq_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FunctionMessageResponse::set_has_seq_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FunctionMessageResponse::clear_has_seq_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FunctionMessageResponse::clear_seq_id() {
  seq_id_ = GOOGLE_LONGLONG(0);
  clear_has_seq_id();
}
inline ::google::protobuf::int64 FunctionMessageResponse::seq_id() const {
  // @@protoc_insertion_point(field_get:boyim_proto.FunctionMessageResponse.seq_id)
  return seq_id_;
}
inline void FunctionMessageResponse::set_seq_id(::google::protobuf::int64 value) {
  set_has_seq_id();
  seq_id_ = value;
  // @@protoc_insertion_point(field_set:boyim_proto.FunctionMessageResponse.seq_id)
}

// -------------------------------------------------------------------

// LogoutMessage

// required .boyim_proto.Header header = 1;
inline bool LogoutMessage::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogoutMessage::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogoutMessage::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogoutMessage::clear_header() {
  if (header_ != NULL) header_->::boyim_proto::Header::Clear();
  clear_has_header();
}
inline const ::boyim_proto::Header& LogoutMessage::header() const {
  // @@protoc_insertion_point(field_get:boyim_proto.LogoutMessage.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::boyim_proto::Header* LogoutMessage::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::boyim_proto::Header;
  // @@protoc_insertion_point(field_mutable:boyim_proto.LogoutMessage.header)
  return header_;
}
inline ::boyim_proto::Header* LogoutMessage::release_header() {
  clear_has_header();
  ::boyim_proto::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void LogoutMessage::set_allocated_header(::boyim_proto::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:boyim_proto.LogoutMessage.header)
}

// optional string session_id = 2;
inline bool LogoutMessage::has_session_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LogoutMessage::set_has_session_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LogoutMessage::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LogoutMessage::clear_session_id() {
  if (session_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_id_->clear();
  }
  clear_has_session_id();
}
inline const ::std::string& LogoutMessage::session_id() const {
  // @@protoc_insertion_point(field_get:boyim_proto.LogoutMessage.session_id)
  return *session_id_;
}
inline void LogoutMessage::set_session_id(const ::std::string& value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
  // @@protoc_insertion_point(field_set:boyim_proto.LogoutMessage.session_id)
}
inline void LogoutMessage::set_session_id(const char* value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:boyim_proto.LogoutMessage.session_id)
}
inline void LogoutMessage::set_session_id(const char* value, size_t size) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:boyim_proto.LogoutMessage.session_id)
}
inline ::std::string* LogoutMessage::mutable_session_id() {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:boyim_proto.LogoutMessage.session_id)
  return session_id_;
}
inline ::std::string* LogoutMessage::release_session_id() {
  clear_has_session_id();
  if (session_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = session_id_;
    session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LogoutMessage::set_allocated_session_id(::std::string* session_id) {
  if (session_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete session_id_;
  }
  if (session_id) {
    set_has_session_id();
    session_id_ = session_id;
  } else {
    clear_has_session_id();
    session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:boyim_proto.LogoutMessage.session_id)
}

// optional int64 clock = 3;
inline bool LogoutMessage::has_clock() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LogoutMessage::set_has_clock() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LogoutMessage::clear_has_clock() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LogoutMessage::clear_clock() {
  clock_ = GOOGLE_LONGLONG(0);
  clear_has_clock();
}
inline ::google::protobuf::int64 LogoutMessage::clock() const {
  // @@protoc_insertion_point(field_get:boyim_proto.LogoutMessage.clock)
  return clock_;
}
inline void LogoutMessage::set_clock(::google::protobuf::int64 value) {
  set_has_clock();
  clock_ = value;
  // @@protoc_insertion_point(field_set:boyim_proto.LogoutMessage.clock)
}

// optional string service_gid = 4;
inline bool LogoutMessage::has_service_gid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LogoutMessage::set_has_service_gid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LogoutMessage::clear_has_service_gid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LogoutMessage::clear_service_gid() {
  if (service_gid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_gid_->clear();
  }
  clear_has_service_gid();
}
inline const ::std::string& LogoutMessage::service_gid() const {
  // @@protoc_insertion_point(field_get:boyim_proto.LogoutMessage.service_gid)
  return *service_gid_;
}
inline void LogoutMessage::set_service_gid(const ::std::string& value) {
  set_has_service_gid();
  if (service_gid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_gid_ = new ::std::string;
  }
  service_gid_->assign(value);
  // @@protoc_insertion_point(field_set:boyim_proto.LogoutMessage.service_gid)
}
inline void LogoutMessage::set_service_gid(const char* value) {
  set_has_service_gid();
  if (service_gid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_gid_ = new ::std::string;
  }
  service_gid_->assign(value);
  // @@protoc_insertion_point(field_set_char:boyim_proto.LogoutMessage.service_gid)
}
inline void LogoutMessage::set_service_gid(const char* value, size_t size) {
  set_has_service_gid();
  if (service_gid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_gid_ = new ::std::string;
  }
  service_gid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:boyim_proto.LogoutMessage.service_gid)
}
inline ::std::string* LogoutMessage::mutable_service_gid() {
  set_has_service_gid();
  if (service_gid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_gid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:boyim_proto.LogoutMessage.service_gid)
  return service_gid_;
}
inline ::std::string* LogoutMessage::release_service_gid() {
  clear_has_service_gid();
  if (service_gid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = service_gid_;
    service_gid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LogoutMessage::set_allocated_service_gid(::std::string* service_gid) {
  if (service_gid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete service_gid_;
  }
  if (service_gid) {
    set_has_service_gid();
    service_gid_ = service_gid;
  } else {
    clear_has_service_gid();
    service_gid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:boyim_proto.LogoutMessage.service_gid)
}

// optional string service_site_id = 5;
inline bool LogoutMessage::has_service_site_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LogoutMessage::set_has_service_site_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LogoutMessage::clear_has_service_site_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LogoutMessage::clear_service_site_id() {
  if (service_site_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_site_id_->clear();
  }
  clear_has_service_site_id();
}
inline const ::std::string& LogoutMessage::service_site_id() const {
  // @@protoc_insertion_point(field_get:boyim_proto.LogoutMessage.service_site_id)
  return *service_site_id_;
}
inline void LogoutMessage::set_service_site_id(const ::std::string& value) {
  set_has_service_site_id();
  if (service_site_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_site_id_ = new ::std::string;
  }
  service_site_id_->assign(value);
  // @@protoc_insertion_point(field_set:boyim_proto.LogoutMessage.service_site_id)
}
inline void LogoutMessage::set_service_site_id(const char* value) {
  set_has_service_site_id();
  if (service_site_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_site_id_ = new ::std::string;
  }
  service_site_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:boyim_proto.LogoutMessage.service_site_id)
}
inline void LogoutMessage::set_service_site_id(const char* value, size_t size) {
  set_has_service_site_id();
  if (service_site_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_site_id_ = new ::std::string;
  }
  service_site_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:boyim_proto.LogoutMessage.service_site_id)
}
inline ::std::string* LogoutMessage::mutable_service_site_id() {
  set_has_service_site_id();
  if (service_site_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_site_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:boyim_proto.LogoutMessage.service_site_id)
  return service_site_id_;
}
inline ::std::string* LogoutMessage::release_service_site_id() {
  clear_has_service_site_id();
  if (service_site_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = service_site_id_;
    service_site_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LogoutMessage::set_allocated_service_site_id(::std::string* service_site_id) {
  if (service_site_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete service_site_id_;
  }
  if (service_site_id) {
    set_has_service_site_id();
    service_site_id_ = service_site_id;
  } else {
    clear_has_service_site_id();
    service_site_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:boyim_proto.LogoutMessage.service_site_id)
}

// optional string service_station_id = 6;
inline bool LogoutMessage::has_service_station_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LogoutMessage::set_has_service_station_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LogoutMessage::clear_has_service_station_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LogoutMessage::clear_service_station_id() {
  if (service_station_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_station_id_->clear();
  }
  clear_has_service_station_id();
}
inline const ::std::string& LogoutMessage::service_station_id() const {
  // @@protoc_insertion_point(field_get:boyim_proto.LogoutMessage.service_station_id)
  return *service_station_id_;
}
inline void LogoutMessage::set_service_station_id(const ::std::string& value) {
  set_has_service_station_id();
  if (service_station_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_station_id_ = new ::std::string;
  }
  service_station_id_->assign(value);
  // @@protoc_insertion_point(field_set:boyim_proto.LogoutMessage.service_station_id)
}
inline void LogoutMessage::set_service_station_id(const char* value) {
  set_has_service_station_id();
  if (service_station_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_station_id_ = new ::std::string;
  }
  service_station_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:boyim_proto.LogoutMessage.service_station_id)
}
inline void LogoutMessage::set_service_station_id(const char* value, size_t size) {
  set_has_service_station_id();
  if (service_station_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_station_id_ = new ::std::string;
  }
  service_station_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:boyim_proto.LogoutMessage.service_station_id)
}
inline ::std::string* LogoutMessage::mutable_service_station_id() {
  set_has_service_station_id();
  if (service_station_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_station_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:boyim_proto.LogoutMessage.service_station_id)
  return service_station_id_;
}
inline ::std::string* LogoutMessage::release_service_station_id() {
  clear_has_service_station_id();
  if (service_station_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = service_station_id_;
    service_station_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LogoutMessage::set_allocated_service_station_id(::std::string* service_station_id) {
  if (service_station_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete service_station_id_;
  }
  if (service_station_id) {
    set_has_service_station_id();
    service_station_id_ = service_station_id;
  } else {
    clear_has_service_station_id();
    service_station_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:boyim_proto.LogoutMessage.service_station_id)
}

// optional int32 end_type = 7;
inline bool LogoutMessage::has_end_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LogoutMessage::set_has_end_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LogoutMessage::clear_has_end_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LogoutMessage::clear_end_type() {
  end_type_ = 0;
  clear_has_end_type();
}
inline ::google::protobuf::int32 LogoutMessage::end_type() const {
  // @@protoc_insertion_point(field_get:boyim_proto.LogoutMessage.end_type)
  return end_type_;
}
inline void LogoutMessage::set_end_type(::google::protobuf::int32 value) {
  set_has_end_type();
  end_type_ = value;
  // @@protoc_insertion_point(field_set:boyim_proto.LogoutMessage.end_type)
}

// optional string extra = 11;
inline bool LogoutMessage::has_extra() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LogoutMessage::set_has_extra() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LogoutMessage::clear_has_extra() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LogoutMessage::clear_extra() {
  if (extra_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extra_->clear();
  }
  clear_has_extra();
}
inline const ::std::string& LogoutMessage::extra() const {
  // @@protoc_insertion_point(field_get:boyim_proto.LogoutMessage.extra)
  return *extra_;
}
inline void LogoutMessage::set_extra(const ::std::string& value) {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extra_ = new ::std::string;
  }
  extra_->assign(value);
  // @@protoc_insertion_point(field_set:boyim_proto.LogoutMessage.extra)
}
inline void LogoutMessage::set_extra(const char* value) {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extra_ = new ::std::string;
  }
  extra_->assign(value);
  // @@protoc_insertion_point(field_set_char:boyim_proto.LogoutMessage.extra)
}
inline void LogoutMessage::set_extra(const char* value, size_t size) {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extra_ = new ::std::string;
  }
  extra_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:boyim_proto.LogoutMessage.extra)
}
inline ::std::string* LogoutMessage::mutable_extra() {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extra_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:boyim_proto.LogoutMessage.extra)
  return extra_;
}
inline ::std::string* LogoutMessage::release_extra() {
  clear_has_extra();
  if (extra_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = extra_;
    extra_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LogoutMessage::set_allocated_extra(::std::string* extra) {
  if (extra_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete extra_;
  }
  if (extra) {
    set_has_extra();
    extra_ = extra;
  } else {
    clear_has_extra();
    extra_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:boyim_proto.LogoutMessage.extra)
}

// -------------------------------------------------------------------

// ServiceStatus

// required .boyim_proto.Header header = 1;
inline bool ServiceStatus::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServiceStatus::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServiceStatus::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServiceStatus::clear_header() {
  if (header_ != NULL) header_->::boyim_proto::Header::Clear();
  clear_has_header();
}
inline const ::boyim_proto::Header& ServiceStatus::header() const {
  // @@protoc_insertion_point(field_get:boyim_proto.ServiceStatus.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::boyim_proto::Header* ServiceStatus::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::boyim_proto::Header;
  // @@protoc_insertion_point(field_mutable:boyim_proto.ServiceStatus.header)
  return header_;
}
inline ::boyim_proto::Header* ServiceStatus::release_header() {
  clear_has_header();
  ::boyim_proto::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void ServiceStatus::set_allocated_header(::boyim_proto::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:boyim_proto.ServiceStatus.header)
}

// required int32 status = 2;
inline bool ServiceStatus::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServiceStatus::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServiceStatus::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServiceStatus::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 ServiceStatus::status() const {
  // @@protoc_insertion_point(field_get:boyim_proto.ServiceStatus.status)
  return status_;
}
inline void ServiceStatus::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:boyim_proto.ServiceStatus.status)
}

// -------------------------------------------------------------------

// ShiftSession

// required .boyim_proto.Header header = 1;
inline bool ShiftSession::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShiftSession::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShiftSession::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShiftSession::clear_header() {
  if (header_ != NULL) header_->::boyim_proto::Header::Clear();
  clear_has_header();
}
inline const ::boyim_proto::Header& ShiftSession::header() const {
  // @@protoc_insertion_point(field_get:boyim_proto.ShiftSession.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::boyim_proto::Header* ShiftSession::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::boyim_proto::Header;
  // @@protoc_insertion_point(field_mutable:boyim_proto.ShiftSession.header)
  return header_;
}
inline ::boyim_proto::Header* ShiftSession::release_header() {
  clear_has_header();
  ::boyim_proto::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void ShiftSession::set_allocated_header(::boyim_proto::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:boyim_proto.ShiftSession.header)
}

// required string session_id = 2;
inline bool ShiftSession::has_session_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShiftSession::set_has_session_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShiftSession::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShiftSession::clear_session_id() {
  if (session_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_id_->clear();
  }
  clear_has_session_id();
}
inline const ::std::string& ShiftSession::session_id() const {
  // @@protoc_insertion_point(field_get:boyim_proto.ShiftSession.session_id)
  return *session_id_;
}
inline void ShiftSession::set_session_id(const ::std::string& value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
  // @@protoc_insertion_point(field_set:boyim_proto.ShiftSession.session_id)
}
inline void ShiftSession::set_session_id(const char* value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:boyim_proto.ShiftSession.session_id)
}
inline void ShiftSession::set_session_id(const char* value, size_t size) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:boyim_proto.ShiftSession.session_id)
}
inline ::std::string* ShiftSession::mutable_session_id() {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:boyim_proto.ShiftSession.session_id)
  return session_id_;
}
inline ::std::string* ShiftSession::release_session_id() {
  clear_has_session_id();
  if (session_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = session_id_;
    session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ShiftSession::set_allocated_session_id(::std::string* session_id) {
  if (session_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete session_id_;
  }
  if (session_id) {
    set_has_session_id();
    session_id_ = session_id;
  } else {
    clear_has_session_id();
    session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:boyim_proto.ShiftSession.session_id)
}

// required string shift_to_fid = 3;
inline bool ShiftSession::has_shift_to_fid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ShiftSession::set_has_shift_to_fid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ShiftSession::clear_has_shift_to_fid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ShiftSession::clear_shift_to_fid() {
  if (shift_to_fid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shift_to_fid_->clear();
  }
  clear_has_shift_to_fid();
}
inline const ::std::string& ShiftSession::shift_to_fid() const {
  // @@protoc_insertion_point(field_get:boyim_proto.ShiftSession.shift_to_fid)
  return *shift_to_fid_;
}
inline void ShiftSession::set_shift_to_fid(const ::std::string& value) {
  set_has_shift_to_fid();
  if (shift_to_fid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shift_to_fid_ = new ::std::string;
  }
  shift_to_fid_->assign(value);
  // @@protoc_insertion_point(field_set:boyim_proto.ShiftSession.shift_to_fid)
}
inline void ShiftSession::set_shift_to_fid(const char* value) {
  set_has_shift_to_fid();
  if (shift_to_fid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shift_to_fid_ = new ::std::string;
  }
  shift_to_fid_->assign(value);
  // @@protoc_insertion_point(field_set_char:boyim_proto.ShiftSession.shift_to_fid)
}
inline void ShiftSession::set_shift_to_fid(const char* value, size_t size) {
  set_has_shift_to_fid();
  if (shift_to_fid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shift_to_fid_ = new ::std::string;
  }
  shift_to_fid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:boyim_proto.ShiftSession.shift_to_fid)
}
inline ::std::string* ShiftSession::mutable_shift_to_fid() {
  set_has_shift_to_fid();
  if (shift_to_fid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shift_to_fid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:boyim_proto.ShiftSession.shift_to_fid)
  return shift_to_fid_;
}
inline ::std::string* ShiftSession::release_shift_to_fid() {
  clear_has_shift_to_fid();
  if (shift_to_fid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = shift_to_fid_;
    shift_to_fid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ShiftSession::set_allocated_shift_to_fid(::std::string* shift_to_fid) {
  if (shift_to_fid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete shift_to_fid_;
  }
  if (shift_to_fid) {
    set_has_shift_to_fid();
    shift_to_fid_ = shift_to_fid;
  } else {
    clear_has_shift_to_fid();
    shift_to_fid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:boyim_proto.ShiftSession.shift_to_fid)
}

// -------------------------------------------------------------------

// EndSession

// required .boyim_proto.Header header = 1;
inline bool EndSession::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EndSession::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EndSession::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EndSession::clear_header() {
  if (header_ != NULL) header_->::boyim_proto::Header::Clear();
  clear_has_header();
}
inline const ::boyim_proto::Header& EndSession::header() const {
  // @@protoc_insertion_point(field_get:boyim_proto.EndSession.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::boyim_proto::Header* EndSession::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::boyim_proto::Header;
  // @@protoc_insertion_point(field_mutable:boyim_proto.EndSession.header)
  return header_;
}
inline ::boyim_proto::Header* EndSession::release_header() {
  clear_has_header();
  ::boyim_proto::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void EndSession::set_allocated_header(::boyim_proto::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:boyim_proto.EndSession.header)
}

// required string session_id = 2;
inline bool EndSession::has_session_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EndSession::set_has_session_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EndSession::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EndSession::clear_session_id() {
  if (session_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_id_->clear();
  }
  clear_has_session_id();
}
inline const ::std::string& EndSession::session_id() const {
  // @@protoc_insertion_point(field_get:boyim_proto.EndSession.session_id)
  return *session_id_;
}
inline void EndSession::set_session_id(const ::std::string& value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
  // @@protoc_insertion_point(field_set:boyim_proto.EndSession.session_id)
}
inline void EndSession::set_session_id(const char* value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:boyim_proto.EndSession.session_id)
}
inline void EndSession::set_session_id(const char* value, size_t size) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:boyim_proto.EndSession.session_id)
}
inline ::std::string* EndSession::mutable_session_id() {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:boyim_proto.EndSession.session_id)
  return session_id_;
}
inline ::std::string* EndSession::release_session_id() {
  clear_has_session_id();
  if (session_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = session_id_;
    session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void EndSession::set_allocated_session_id(::std::string* session_id) {
  if (session_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete session_id_;
  }
  if (session_id) {
    set_has_session_id();
    session_id_ = session_id;
  } else {
    clear_has_session_id();
    session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:boyim_proto.EndSession.session_id)
}

// required string client_gid = 3;
inline bool EndSession::has_client_gid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EndSession::set_has_client_gid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EndSession::clear_has_client_gid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EndSession::clear_client_gid() {
  if (client_gid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_gid_->clear();
  }
  clear_has_client_gid();
}
inline const ::std::string& EndSession::client_gid() const {
  // @@protoc_insertion_point(field_get:boyim_proto.EndSession.client_gid)
  return *client_gid_;
}
inline void EndSession::set_client_gid(const ::std::string& value) {
  set_has_client_gid();
  if (client_gid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_gid_ = new ::std::string;
  }
  client_gid_->assign(value);
  // @@protoc_insertion_point(field_set:boyim_proto.EndSession.client_gid)
}
inline void EndSession::set_client_gid(const char* value) {
  set_has_client_gid();
  if (client_gid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_gid_ = new ::std::string;
  }
  client_gid_->assign(value);
  // @@protoc_insertion_point(field_set_char:boyim_proto.EndSession.client_gid)
}
inline void EndSession::set_client_gid(const char* value, size_t size) {
  set_has_client_gid();
  if (client_gid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_gid_ = new ::std::string;
  }
  client_gid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:boyim_proto.EndSession.client_gid)
}
inline ::std::string* EndSession::mutable_client_gid() {
  set_has_client_gid();
  if (client_gid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_gid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:boyim_proto.EndSession.client_gid)
  return client_gid_;
}
inline ::std::string* EndSession::release_client_gid() {
  clear_has_client_gid();
  if (client_gid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = client_gid_;
    client_gid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void EndSession::set_allocated_client_gid(::std::string* client_gid) {
  if (client_gid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete client_gid_;
  }
  if (client_gid) {
    set_has_client_gid();
    client_gid_ = client_gid;
  } else {
    clear_has_client_gid();
    client_gid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:boyim_proto.EndSession.client_gid)
}

// required string client_site_id = 4;
inline bool EndSession::has_client_site_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EndSession::set_has_client_site_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EndSession::clear_has_client_site_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EndSession::clear_client_site_id() {
  if (client_site_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_site_id_->clear();
  }
  clear_has_client_site_id();
}
inline const ::std::string& EndSession::client_site_id() const {
  // @@protoc_insertion_point(field_get:boyim_proto.EndSession.client_site_id)
  return *client_site_id_;
}
inline void EndSession::set_client_site_id(const ::std::string& value) {
  set_has_client_site_id();
  if (client_site_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_site_id_ = new ::std::string;
  }
  client_site_id_->assign(value);
  // @@protoc_insertion_point(field_set:boyim_proto.EndSession.client_site_id)
}
inline void EndSession::set_client_site_id(const char* value) {
  set_has_client_site_id();
  if (client_site_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_site_id_ = new ::std::string;
  }
  client_site_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:boyim_proto.EndSession.client_site_id)
}
inline void EndSession::set_client_site_id(const char* value, size_t size) {
  set_has_client_site_id();
  if (client_site_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_site_id_ = new ::std::string;
  }
  client_site_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:boyim_proto.EndSession.client_site_id)
}
inline ::std::string* EndSession::mutable_client_site_id() {
  set_has_client_site_id();
  if (client_site_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_site_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:boyim_proto.EndSession.client_site_id)
  return client_site_id_;
}
inline ::std::string* EndSession::release_client_site_id() {
  clear_has_client_site_id();
  if (client_site_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = client_site_id_;
    client_site_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void EndSession::set_allocated_client_site_id(::std::string* client_site_id) {
  if (client_site_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete client_site_id_;
  }
  if (client_site_id) {
    set_has_client_site_id();
    client_site_id_ = client_site_id;
  } else {
    clear_has_client_site_id();
    client_site_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:boyim_proto.EndSession.client_site_id)
}

// required string client_station_id = 5;
inline bool EndSession::has_client_station_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EndSession::set_has_client_station_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EndSession::clear_has_client_station_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EndSession::clear_client_station_id() {
  if (client_station_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_station_id_->clear();
  }
  clear_has_client_station_id();
}
inline const ::std::string& EndSession::client_station_id() const {
  // @@protoc_insertion_point(field_get:boyim_proto.EndSession.client_station_id)
  return *client_station_id_;
}
inline void EndSession::set_client_station_id(const ::std::string& value) {
  set_has_client_station_id();
  if (client_station_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_station_id_ = new ::std::string;
  }
  client_station_id_->assign(value);
  // @@protoc_insertion_point(field_set:boyim_proto.EndSession.client_station_id)
}
inline void EndSession::set_client_station_id(const char* value) {
  set_has_client_station_id();
  if (client_station_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_station_id_ = new ::std::string;
  }
  client_station_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:boyim_proto.EndSession.client_station_id)
}
inline void EndSession::set_client_station_id(const char* value, size_t size) {
  set_has_client_station_id();
  if (client_station_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_station_id_ = new ::std::string;
  }
  client_station_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:boyim_proto.EndSession.client_station_id)
}
inline ::std::string* EndSession::mutable_client_station_id() {
  set_has_client_station_id();
  if (client_station_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_station_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:boyim_proto.EndSession.client_station_id)
  return client_station_id_;
}
inline ::std::string* EndSession::release_client_station_id() {
  clear_has_client_station_id();
  if (client_station_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = client_station_id_;
    client_station_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void EndSession::set_allocated_client_station_id(::std::string* client_station_id) {
  if (client_station_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete client_station_id_;
  }
  if (client_station_id) {
    set_has_client_station_id();
    client_station_id_ = client_station_id;
  } else {
    clear_has_client_station_id();
    client_station_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:boyim_proto.EndSession.client_station_id)
}

// optional int32 archive_class = 6;
inline bool EndSession::has_archive_class() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EndSession::set_has_archive_class() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EndSession::clear_has_archive_class() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EndSession::clear_archive_class() {
  archive_class_ = 0;
  clear_has_archive_class();
}
inline ::google::protobuf::int32 EndSession::archive_class() const {
  // @@protoc_insertion_point(field_get:boyim_proto.EndSession.archive_class)
  return archive_class_;
}
inline void EndSession::set_archive_class(::google::protobuf::int32 value) {
  set_has_archive_class();
  archive_class_ = value;
  // @@protoc_insertion_point(field_set:boyim_proto.EndSession.archive_class)
}

// optional int32 archive_category = 7;
inline bool EndSession::has_archive_category() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void EndSession::set_has_archive_category() {
  _has_bits_[0] |= 0x00000040u;
}
inline void EndSession::clear_has_archive_category() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void EndSession::clear_archive_category() {
  archive_category_ = 0;
  clear_has_archive_category();
}
inline ::google::protobuf::int32 EndSession::archive_category() const {
  // @@protoc_insertion_point(field_get:boyim_proto.EndSession.archive_category)
  return archive_category_;
}
inline void EndSession::set_archive_category(::google::protobuf::int32 value) {
  set_has_archive_category();
  archive_category_ = value;
  // @@protoc_insertion_point(field_set:boyim_proto.EndSession.archive_category)
}

// optional int32 session_upgraded = 8;
inline bool EndSession::has_session_upgraded() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void EndSession::set_has_session_upgraded() {
  _has_bits_[0] |= 0x00000080u;
}
inline void EndSession::clear_has_session_upgraded() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void EndSession::clear_session_upgraded() {
  session_upgraded_ = 0;
  clear_has_session_upgraded();
}
inline ::google::protobuf::int32 EndSession::session_upgraded() const {
  // @@protoc_insertion_point(field_get:boyim_proto.EndSession.session_upgraded)
  return session_upgraded_;
}
inline void EndSession::set_session_upgraded(::google::protobuf::int32 value) {
  set_has_session_upgraded();
  session_upgraded_ = value;
  // @@protoc_insertion_point(field_set:boyim_proto.EndSession.session_upgraded)
}

// optional int32 session_invalid = 9;
inline bool EndSession::has_session_invalid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void EndSession::set_has_session_invalid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void EndSession::clear_has_session_invalid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void EndSession::clear_session_invalid() {
  session_invalid_ = 0;
  clear_has_session_invalid();
}
inline ::google::protobuf::int32 EndSession::session_invalid() const {
  // @@protoc_insertion_point(field_get:boyim_proto.EndSession.session_invalid)
  return session_invalid_;
}
inline void EndSession::set_session_invalid(::google::protobuf::int32 value) {
  set_has_session_invalid();
  session_invalid_ = value;
  // @@protoc_insertion_point(field_set:boyim_proto.EndSession.session_invalid)
}

// optional int32 end_type = 10;
inline bool EndSession::has_end_type() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void EndSession::set_has_end_type() {
  _has_bits_[0] |= 0x00000200u;
}
inline void EndSession::clear_has_end_type() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void EndSession::clear_end_type() {
  end_type_ = 0;
  clear_has_end_type();
}
inline ::google::protobuf::int32 EndSession::end_type() const {
  // @@protoc_insertion_point(field_get:boyim_proto.EndSession.end_type)
  return end_type_;
}
inline void EndSession::set_end_type(::google::protobuf::int32 value) {
  set_has_end_type();
  end_type_ = value;
  // @@protoc_insertion_point(field_set:boyim_proto.EndSession.end_type)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace boyim_proto

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_boyim_2eproto__INCLUDED
